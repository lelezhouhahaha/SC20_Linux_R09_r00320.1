From b55f40f81670b97b7b39e5c7c78bb77205cf7aaf Mon Sep 17 00:00:00 2001
From: Chapin Fang <chapin.fang@quectel.com>
Date: Sat, 29 Jun 2019 17:02:47 +0800
Subject: [PATCH] support opengl offscreen in linuxfb

Change-Id: I0e1320a510c07cc5ce6d5041180cbe9739401bda
---
 mkspecs/common/linux.conf                          |   4 +-
 src/gui/configure.json                             |  24 +-
 .../androidmini/androiddeadlockprotector.h         |  73 +++
 src/plugins/platforms/androidmini/androidmini.json |   3 +
 src/plugins/platforms/androidmini/androidmini.pro  |  47 ++
 .../platforms/androidmini/androidsurfaceclient.h   |  60 ++
 src/plugins/platforms/androidmini/common.h         | 531 +++++++++++++++++
 src/plugins/platforms/androidmini/main.cpp         |  65 +++
 .../qandroidassetsfileenginehandler.cpp            | 396 +++++++++++++
 .../androidmini/qandroidassetsfileenginehandler.h  |  72 +++
 .../androidmini/qandroideventdispatcher.cpp        | 145 +++++
 .../androidmini/qandroideventdispatcher.h          |  85 +++
 .../platforms/androidmini/qandroidinputcontext.h   | 160 ++++++
 .../androidmini/qandroidplatformaccessibility.cpp  |  59 ++
 .../androidmini/qandroidplatformaccessibility.h    |  59 ++
 .../androidmini/qandroidplatformbackingstore.cpp   |  93 +++
 .../androidmini/qandroidplatformbackingstore.h     |  65 +++
 .../androidmini/qandroidplatformclipboard.cpp      |  76 +++
 .../androidmini/qandroidplatformclipboard.h        |  65 +++
 .../androidmini/qandroidplatformdialoghelpers.cpp  | 193 +++++++
 .../androidmini/qandroidplatformdialoghelpers.h    |  80 +++
 .../androidmini/qandroidplatformfontdatabase.cpp   |  90 +++
 .../androidmini/qandroidplatformfontdatabase.h     |  60 ++
 .../androidmini/qandroidplatformforeignwindow.cpp  | 125 +++++
 .../androidmini/qandroidplatformforeignwindow.h    |  69 +++
 .../qandroidplatformoffscreensurface.cpp           |  73 +++
 .../androidmini/qandroidplatformoffscreensurface.h |  67 +++
 .../androidmini/qandroidplatformopenglcontext.cpp  |  88 +++
 .../androidmini/qandroidplatformopenglcontext.h    |  62 ++
 .../androidmini/qandroidplatformopenglwindow.cpp   | 197 +++++++
 .../androidmini/qandroidplatformopenglwindow.h     | 107 ++++
 .../androidmini/qandroidplatformscreen.cpp         | 625 +++++++++++++++++++++
 .../platforms/androidmini/qandroidplatformscreen.h | 135 +++++
 .../androidmini/qandroidplatformservices.cpp       |  86 +++
 .../androidmini/qandroidplatformservices.h         |  59 ++
 .../androidmini/qandroidplatformsurface.cpp        |  52 ++
 .../androidmini/qandroidplatformsurface.h          |  36 ++
 .../platforms/androidmini/qandroidplatformtheme.h  |  88 +++
 .../androidmini/qandroidplatformwindow.cpp         | 179 ++++++
 .../platforms/androidmini/qandroidplatformwindow.h | 110 ++++
 .../platforms/androidmini/qandroidsystemlocale.cpp | 177 ++++++
 .../platforms/androidmini/qandroidsystemlocale.h   |  65 +++
 .../platforms/androidmini/qlinuxfbdrmscreen.cpp    | 412 ++++++++++++++
 .../platforms/androidmini/qlinuxfbdrmscreen.h      |  68 +++
 .../platforms/androidmini/qlinuxfbintegration.cpp  | 260 +++++++++
 .../platforms/androidmini/qlinuxfbintegration.h    | 121 ++++
 .../platforms/androidmini/qlinuxfbscreen.cpp       | 450 +++++++++++++++
 src/plugins/platforms/androidmini/qlinuxfbscreen.h |  83 +++
 src/plugins/platforms/androidmini/view.h           |  31 +
 src/plugins/platforms/linuxfb/linuxfb.pro          |   8 +-
 .../platforms/linuxfb/qlinuxfbintegration.cpp      |  48 ++
 .../platforms/linuxfb/qlinuxfbintegration.h        |  13 +
 .../platforms/linuxfb/qlinuxfbopenglcontext.cpp    |  78 +++
 .../platforms/linuxfb/qlinuxfbopenglcontext.h      |  62 ++
 src/plugins/platforms/linuxfb/qlinuxfbscreen.cpp   |   2 +
 src/plugins/platforms/platforms.pro                |   2 +
 56 files changed, 6537 insertions(+), 6 deletions(-)
 mode change 100644 => 100755 src/gui/configure.json
 create mode 100755 src/plugins/platforms/androidmini/androiddeadlockprotector.h
 create mode 100755 src/plugins/platforms/androidmini/androidmini.json
 create mode 100755 src/plugins/platforms/androidmini/androidmini.pro
 create mode 100755 src/plugins/platforms/androidmini/androidsurfaceclient.h
 create mode 100755 src/plugins/platforms/androidmini/common.h
 create mode 100755 src/plugins/platforms/androidmini/main.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.h
 create mode 100755 src/plugins/platforms/androidmini/qandroideventdispatcher.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroideventdispatcher.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidinputcontext.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformaccessibility.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformaccessibility.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformbackingstore.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformbackingstore.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformclipboard.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformclipboard.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformfontdatabase.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformfontdatabase.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformforeignwindow.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformforeignwindow.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformopenglcontext.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformopenglcontext.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformopenglwindow.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformopenglwindow.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformscreen.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformscreen.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformservices.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformservices.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformsurface.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformsurface.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformtheme.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformwindow.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidplatformwindow.h
 create mode 100755 src/plugins/platforms/androidmini/qandroidsystemlocale.cpp
 create mode 100755 src/plugins/platforms/androidmini/qandroidsystemlocale.h
 create mode 100755 src/plugins/platforms/androidmini/qlinuxfbdrmscreen.cpp
 create mode 100755 src/plugins/platforms/androidmini/qlinuxfbdrmscreen.h
 create mode 100755 src/plugins/platforms/androidmini/qlinuxfbintegration.cpp
 create mode 100755 src/plugins/platforms/androidmini/qlinuxfbintegration.h
 create mode 100644 src/plugins/platforms/androidmini/qlinuxfbscreen.cpp
 create mode 100644 src/plugins/platforms/androidmini/qlinuxfbscreen.h
 create mode 100755 src/plugins/platforms/androidmini/view.h
 create mode 100755 src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.cpp
 create mode 100755 src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.h

diff --git a/mkspecs/common/linux.conf b/mkspecs/common/linux.conf
index 68e566a..9fa5138 100644
--- a/mkspecs/common/linux.conf
+++ b/mkspecs/common/linux.conf
@@ -29,9 +29,9 @@ QMAKE_LIBDIR_OPENVG     =
 QMAKE_LIBS              =
 QMAKE_LIBS_DYNLOAD      = -ldl
 QMAKE_LIBS_X11          = -lXext -lX11 -lm
-QMAKE_LIBS_EGL          = -lEGL
+QMAKE_LIBS_EGL          = -lEGL_adreno
 QMAKE_LIBS_OPENGL       = -lGL
-QMAKE_LIBS_OPENGL_ES2   = -lGLESv2
+QMAKE_LIBS_OPENGL_ES2   = -lGLESv2_adreno
 QMAKE_LIBS_OPENVG       = -lOpenVG
 QMAKE_LIBS_THREAD       = -lpthread
 
diff --git a/src/gui/configure.json b/src/gui/configure.json
old mode 100644
new mode 100755
index 1e4e564..3cf0eeb
--- a/src/gui/configure.json
+++ b/src/gui/configure.json
@@ -29,6 +29,7 @@
             "libjpeg": { "type": "enum", "values": [ "no", "qt", "system" ] },
             "libpng": { "type": "enum", "values": [ "no", "qt", "system" ] },
             "linuxfb": "boolean",
+            "androidmini": "boolean",
             "mirclient": "boolean",
             "mtdev": "boolean",
             "opengl": { "type": "optionalString", "values": [ "no", "yes", "desktop", "es2", "dynamic" ] },
@@ -788,6 +789,20 @@
                 ]
             }
         },
+        "androidmini": {
+            "label": "AndroidMini",
+            "type": "compile",
+            "test": {
+                "include": [ "linux/fb.h", "sys/kd.h", "sys/ioctl.h" ],
+                "main": [
+                    "fb_fix_screeninfo finfo;",
+                    "fb_var_screeninfo vinfo;",
+                    "int fd = 3;",
+                    "ioctl(fd, FBIOGET_FSCREENINFO, &finfo);",
+                    "ioctl(fd, FBIOGET_VSCREENINFO, &vinfo);"
+                ]
+            }
+        },
         "opengles3": {
             "label": "OpenGL ES 3.0",
             "type": "compile",
@@ -997,6 +1012,13 @@
             "condition": "tests.linuxfb && features.regularexpression",
             "output": [ "privateFeature" ]
         },
+        "androidmini": {
+            "label": "AndroidMini",
+            "section": "Platform plugins",
+            "condition": "tests.linuxfb && features.regularexpression",
+            "output": [ "privateFeature" ]
+        },
+
         "vnc": {
             "label": "VNC",
             "section": "Platform plugins",
@@ -1601,7 +1623,7 @@ QMAKE_LIBDIR_OPENGL[_ES2] and QMAKE_LIBS_OPENGL[_ES2] in the mkspec for your pla
                         "eglfs_openwfd", "eglfs_viv", "eglfs_viv_wl", "eglfs_rcar", "eglfs_egldevice", "eglfs_gbm", "eglfs_mali", "eglfs_brcm", "egl_x11"
                     ]
                 },
-                "linuxfb", "vnc", "mirclient",
+                "linuxfb", "androidmini", "vnc", "mirclient",
                 {
                     "type": "feature",
                     "condition": "config.integrity",
diff --git a/src/plugins/platforms/androidmini/androiddeadlockprotector.h b/src/plugins/platforms/androidmini/androiddeadlockprotector.h
new file mode 100755
index 0000000..7fa5bcf
--- /dev/null
+++ b/src/plugins/platforms/androidmini/androiddeadlockprotector.h
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef ANDROID_DEADLOCKPROTECTOR_H
+#define ANDROID_DEADLOCKPROTECTOR_H
+
+#include <QAtomicInt>
+
+QT_BEGIN_NAMESPACE
+
+class AndroidDeadlockProtector
+{
+public:
+    AndroidDeadlockProtector()
+        : m_acquired(0)
+    {
+    }
+
+    ~AndroidDeadlockProtector() {
+        if (m_acquired)
+            s_blocked.storeRelease(0);
+    }
+
+    bool acquire() {
+        m_acquired = s_blocked.testAndSetAcquire(0, 1);
+        return m_acquired;
+    }
+
+private:
+    static QAtomicInt s_blocked;
+    int m_acquired;
+};
+
+QT_END_NAMESPACE
+
+#endif // ANDROID_DEADLOCKPROTECTOR_H
+
diff --git a/src/plugins/platforms/androidmini/androidmini.json b/src/plugins/platforms/androidmini/androidmini.json
new file mode 100755
index 0000000..210b26a
--- /dev/null
+++ b/src/plugins/platforms/androidmini/androidmini.json
@@ -0,0 +1,3 @@
+{
+    "Keys": [ "androidmini" ]
+}
diff --git a/src/plugins/platforms/androidmini/androidmini.pro b/src/plugins/platforms/androidmini/androidmini.pro
new file mode 100755
index 0000000..a9083ab
--- /dev/null
+++ b/src/plugins/platforms/androidmini/androidmini.pro
@@ -0,0 +1,47 @@
+TARGET = qandroidmini
+
+DEFINES += QT_NO_FOREACH
+
+QT += \
+    core-private gui-private \
+    service_support-private eventdispatcher_support-private \
+    fontdatabase_support-private fb_support-private egl_support-private
+
+qtHaveModule(input_support-private): \
+    QT += input_support-private
+
+SOURCES = main.cpp \
+          qlinuxfbintegration.cpp \
+		  qandroidplatformopenglwindow.cpp \
+          qandroidplatformopenglcontext.cpp \
+          qandroidplatformscreen.cpp \
+          qandroideventdispatcher.cpp \
+		  qandroidplatformwindow.cpp \
+		  qandroidplatformbackingstore.cpp \
+          qandroidplatformfontdatabase.cpp \
+		  qandroidplatformoffscreensurface.cpp 
+
+
+HEADERS = qlinuxfbintegration.h \
+		  qandroidplatformopenglwindow.h \
+          qandroidplatformopenglcontext.h \
+          qandroideventdispatcher.h \
+          qandroidplatformfontdatabase.h \
+		  qandroidplatformwindow.h \
+          qandroidplatformscreen.h  \
+		  qandroidplatformbackingstore.h \
+		  qandroidplatformoffscreensurface.h
+
+
+qtHaveModule(kms_support-private) {
+    QT += kms_support-private
+    SOURCES += qlinuxfbdrmscreen.cpp
+    HEADERS += qlinuxfbdrmscreen.h
+}
+
+OTHER_FILES += androidmini.json
+
+PLUGIN_TYPE = platforms
+PLUGIN_CLASS_NAME = QLinuxFbIntegrationPlugin
+!equals(TARGET, $$QT_DEFAULT_QPA_PLUGIN): PLUGIN_EXTENDS = -
+load(qt_plugin)
diff --git a/src/plugins/platforms/androidmini/androidsurfaceclient.h b/src/plugins/platforms/androidmini/androidsurfaceclient.h
new file mode 100755
index 0000000..2dc9c05
--- /dev/null
+++ b/src/plugins/platforms/androidmini/androidsurfaceclient.h
@@ -0,0 +1,60 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef ANDROIDSURFACECLIENT_H
+#define ANDROIDSURFACECLIENT_H
+#include <QMutex>
+//#include <jni.h>  //modify by chapin
+
+QT_BEGIN_NAMESPACE
+
+class AndroidSurfaceClient
+{
+public:
+//   virtual void surfaceChanged(JNIEnv *jniEnv, jobject surface, int w, int h) = 0;   //modify by chapin
+    void lockSurface() { m_surfaceMutex.lock(); }
+    void unlockSurface() { m_surfaceMutex.unlock(); }
+
+protected:
+    QMutex m_surfaceMutex;
+};
+
+QT_END_NAMESPACE
+
+#endif // ANDROIDSURFACECLIENT_H
diff --git a/src/plugins/platforms/androidmini/common.h b/src/plugins/platforms/androidmini/common.h
new file mode 100755
index 0000000..bc1a343
--- /dev/null
+++ b/src/plugins/platforms/androidmini/common.h
@@ -0,0 +1,531 @@
+/*
+ * Copyright (c) 2014-2016, Qualcomm Technologies, Inc.
+ * All Rights Reserved.
+ * Confidential and Proprietary - Qualcomm Technologies, Inc.
+ */
+
+#ifndef __COMMON_H
+#define __COMMON_H
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <ctype.h>
+#include <dlfcn.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <unordered_map>
+#define __STDC_FORMAT_MACROS
+#include <inttypes.h>
+#include <list>
+#include <private/android_filesystem_config.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <sys/prctl.h>
+#include <cstdlib>
+#include <cmath>
+#include <string>
+#include <sys/epoll.h>
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <linux/input.h>
+#include <string.h>
+
+#ifdef USE_GLIB
+#error glib
+#include <glib.h>
+#define strlcat g_strlcat
+#define strlcpy g_strlcpy
+#endif
+
+
+#ifndef ANDROID
+#include <stdio.h>
+#define ALOGE(fmt, args...) do { \
+          fprintf(stderr, fmt"\n", ##args); \
+        } while (0)
+#define ALOGI(fmt, args...) do { \
+          fprintf(stderr, fmt"\n", ##args); \
+        } while (0)
+#define ALOGD(fmt, args...) do { \
+          fprintf(stderr, fmt"\n", ##args); \
+        } while (0)
+#endif
+
+#ifdef LOG_TAG
+#undef LOG_TAG
+#define LOG_TAG   "mmi"
+#endif
+
+using namespace std;
+
+/**Function*/
+#define BITS_PER_LONG  (sizeof(unsigned long) * 8)
+#define BITS_TO_LONGS(x)  (((x) + BITS_PER_LONG - 1) / BITS_PER_LONG)
+#define set_bit(bit, array)   (array)[(bit)/BITS_PER_LONG] |=(1 << ((bit) % BITS_PER_LONG))
+#define clear_bit(bit, array)	(array)[(bit)/BITS_PER_LONG] &=(~ (1 << ((bit) % BITS_PER_LONG)))
+#define test_bit(bit, array)   ((array)[(bit)/BITS_PER_LONG] & (1L << ((bit) % BITS_PER_LONG)))
+
+typedef void (*cb_t) (void *);
+typedef void *(*thread_func_t) (void *);
+
+/**MMI*/
+#define MMI_VERSION "Version 2.0"
+#define MMI_DIAG_READ_VERSION "200"
+
+#define MMI_SOCKET MMI_SOCKET_DIR"mmi"
+#define MMI_SOCKET_DIR "/dev/socket/"
+#define MAIN_MODULE  "MMI"
+#define KEY_CAMERA_SNAPSHOT	0x2fe
+#define MMI_PCBA_SYS_CONFIG "mmi-pcba-sys.cfg"
+#define AUTOSTART_CONFIG ".autostart"
+#define MMI_LOG_FILENAME "mmi.log"
+
+#define MMI_RES_BASE_DIR "/etc/mmi/"
+#define MMI_RES_FONTS MMI_RES_BASE_DIR"fonts.ttf"
+#define MMI_RES_LANG_EN MMI_RES_BASE_DIR"strings.xml"
+#define MMI_RES_LANG_CN MMI_RES_BASE_DIR"strings-zh-rCN.xml"
+
+#define MMI_PCBA_CONFIG get_mmi_cfg_file(CFG_TYPE_MMI_PCBA_CFG)
+#define MMI_PATH_CONFIG MMI_RES_BASE_DIR"path_config.xml"
+
+#define MMI_LAYOUT_BASE_DIR MMI_RES_BASE_DIR"layout/"
+#define MMI_CONFIG get_mmi_cfg_file(CFG_TYPE_MMI_CFG)
+
+#define HOME_SCREENS "home_screens"
+#define LAYOUT_CONFIRM  "layout_confirm.xml"
+#define LAYOUT_REBOOT  "layout_reboot.xml"
+#define LAYOUT_PCBA  "layout_pcba.xml"
+#define LAYOUT_REPORT "layout_report.xml"
+
+#define SIZE_512 512
+#define BLOCK_SIZE 512
+#define SIZE_1K 1024
+#define SIZE_2K (SIZE_1K*2)
+#define SIZE_8K (SIZE_1K*8)
+#define SIZE_1M (SIZE_1K*SIZE_1K)
+#define SIZE_1G (SIZE_1K*SIZE_1K*SIZE_1K)
+
+/**Font size config, percent of LCD density*/
+#define FONT_SIZE_SMALL 3
+#define FONT_SIZE_NORMAL 4
+#define FONT_SIZE_LARGE 6
+#define FONT_SIZE_HUGE 8
+#define FONT_SIZE_HUGER 12
+
+#define SUBCMD_MMI "mmi"
+#define SUBCMD_PCBA "pcba"
+
+#define METHOD "method"
+/**PCBA test method for LCD module*/
+#define LCD_METHOD_READ_ID "read_id"
+#define LCD_METHOD_SHOW_RGB "show_rgb"
+#define LCD_METHOD_SHOW_IMAGE "show_image"
+
+/**PCBA test method for touch module*/
+#define TOUCH_METHOD_READ_EVENT_ID "read_event_id"
+#define TOUCH_METHOD_READ_TOUCH_ID "read_touch_id"
+#define TOUCH_METHOD_TOUCH_TRACK "touch_track"
+#define TOUCH_METHOD_SHOW_RGB "show_rgb"
+
+/**Config file Key words*/
+#define KEY_AUTOMATION "automation"
+#define KEY_TESTMODE "test_mode"
+#define KEY_STR_LANGUAGE "language"
+#define KEY_FONTSIZE "font_size"
+#define KEY_LIB_NAME "lib_name"
+#define KEY_DISPALY_NAME "display_name"
+#define KEY_ENABLE "enable"
+#define KEY_LAYOUT "layout"
+#define KEY_PARAMETER "parameter"
+
+/**Result file keywords*/
+#define KEY_TIMESTAMP_WORDS "Timestamp"
+#define KEY_RESULT_WORDS "Result"
+#define KEY_TESTTIME_WORDS "TestTime_Sec"
+
+/**Button name string list*/
+#define KEY_MAIN_STATUS "main_status"
+#define KEY_MAIN_ALL "main_all"
+#define KEY_MAIN_FAILED "main_failed"
+#define KEY_MAIN_RUNALL "main_runall"
+#define KEY_DISPLAY "display"
+#define KEY_DISPLAY_PCBA "display_pcba"
+#define KEY_REBOOT_ANDROID "reboot_android"
+#define KEY_REBOOT_POWEROFF "reboot_poweroff"
+#define KEY_REBOOT_FFBM "reboot_ffbm"
+#define KEY_MAIN_PASS "sub_pass"
+#define KEY_MAIN_WAIT "wait_test"
+
+#define KEY_STR_EXTRACMD "extracmd"
+#define KEY_STR_EXTRACMDSIZE "extracmd_size"
+#define KEY_BTN "btn"
+#define KEY_PASS "pass"
+#define KEY_FAIL "fail"
+#define KEY_STR_TITLE "title"
+#define KEY_STR_INSTRUCTION "instruction"
+#define KEY_STR_INDICATION "indication"
+#define KEY_STR_FRONT "front"
+#define KEY_STR_BACK "back"
+#define KEY_STR_RESTORE "restore"
+#define KEY_STR_LEFT "left"
+#define KEY_STR_RIGHT "right"
+#define KEY_STR_CENTER "center"
+#define KEY_STR_HOME "home"
+#define KEY_STR_MENU "menu"
+#define KEY_STR_BACK "back"
+#define KEY_STR_VOLUMEUP "volumeup"
+#define KEY_STR_VOLUMEDOWN "volumedown"
+#define KEY_STR_SNAPSHOT "snapshot"
+#define KEY_STR_POWER "power"
+#define KEY_STR_HEADPHONE "headphone"
+#define KEY_STR_MICROPHONE "microphone"
+#define KEY_STR_HANGUP "hangup"
+
+/**Parameter keys*/
+#define KEY_DIMENSION "dimension"
+#define KEY_SMALL "small"
+#define KEY_NORMAL "normal"
+#define KEY_LARGE "large"
+#define KEY_HUGER "huger"
+#define KEY_MIN_LIMINT "min_limit"
+#define KEY_MAX_LIMINT "max_limit"
+
+/**LANGUAGE KEYWORDS*/
+#define KEY_TITLE_PCBA "pcba_title"
+#define KEY_POWER_OFF_NOTICE "power_off_notice"
+#define KEY_RESET_NOTICE "reset_notice"
+#define KEY_REBOOT_NOTICE "reboot_notice"
+#define KEY_RUN_ALL_NOTICE "run_all_notice"
+
+#define MAX_CAM_PREVIEW_BUFFERS 5
+
+/**Diag control mmi commands list*/
+#define CLIENT_DIAG_NAME "DIAG"
+#define CLIENT_DEBUG_NAME "DEBUG"
+
+#define SUBCMD_STAT "stat"                          /**Query the MMI status,include fail case number*/
+#define SUBCMD_RECONFIG "reconfig"        /**Reconfig MMI using one specified CFG file*/
+#define SUBCMD_CLEAR "clear"                     /**Clear the current result file*/
+#define SUBCMD_RUNCASE "runcase"           /**Run specified case*/
+#define SUBCMD_RUNALL "runall"                 /** Start Run all test cases*/
+#define SUBCMD_LISTCASE "listcase"            /** List all the test cases into specified file*/
+#define SUBCMD_EXITCASE "exitcase"          /** Exit the current test case*/
+#define SUBCMD_APPEND_TO_RES "append"       /** Append to result test case*/
+
+/**Keyword used in parameters*/
+#define KEY_MMI_STAT "state"
+#define KEY_FAIL_COUNT "fail_count"
+#define KEY_CFG_PATH "cfg_path"
+#define KEY_TESTLIST_PATH "testlist_path"
+#define KEY_CASE_NUM "case_num"
+#define KEY_CASE_NAME "case_name"
+#define KEY_EXIT_RESULT "exit_result"
+#define KEY_CASE_DATA "case_data"
+
+/**Common keywords***/
+#define KEY_ASCII_TRUE "54525535"   //ASCII for "TRUE"
+
+/**Color value*/
+#define COLOR_RED 0xff0000ff
+#define COLOR_GREEN 0x00ff00ff
+#define COLOR_BLUE 0x0000ffff
+#define COLOR_WHITE 0xffffffff
+#define COLOR_BLACK 0x000000ff
+#define COLOR_KEY_DEFAULT 0x007D7D7D
+
+/**Magnetometer compass value*/
+#define ROUND_ANGLE 360
+#define ROUND_POINT_HALF_SIDE 4
+#define ROUND_POINT_SIDE 8
+#define POINT_HALF_SIDE 16
+#define POINT_SIDE 32
+
+#define IPC_SYNC_USE_SEM_T
+
+
+enum {
+	MAIN_SURFACE = 0,
+	GL_SURFACE = 1,
+};
+
+enum {
+    eOrientationDefault = 0,
+    eOrientation90 = 1,
+    eOrientation180 = 2,
+    eOrientation270 = 3,
+};
+
+
+enum {
+    CONFIG_SUCCESS = 0,
+    CONFIG_NOT_FOUND_ERR = 1,
+    CONFIG_FORTMAT_ERR = 2,
+    CONFIG_TEST_CASE_ERR = 3,
+    CONFIG_NO_DEFAULT_CFG_ERR = 4,
+};
+
+typedef enum {
+    BOOT_MODE_NORMAL = 0,
+    BOOT_MODE_PCBA = 1,
+    BOOT_MODE_UI = 2,
+    MAX_BOOT_MODE,
+} boot_mode_type;
+
+typedef enum {
+    REBOOT_NONE = 0,
+    REBOOT_POWEROFF = 1,
+    REBOOT_FFBM = 2,
+    REBOOT_ANDROID = 3,
+    MAX_REBOOT,
+} reboot_opt_t;
+
+typedef enum {
+    LEVEL_NONE = 0,
+    LEVEL_STANDARD = 1,
+    LEVEL_FUNCTION = 2,
+} level_t;
+
+enum {
+    FAILED = -1,
+    SUCCESS = 0,
+    ERR_UNKNOW = INT_MAX
+};
+
+enum {
+    FTM_SUCCESS = 0,
+    FTM_FAIL = 1,
+};
+
+enum {
+    MMI_IDLE = 0x0,
+    MMI_BUSY = 0x1,
+};
+
+enum {
+    MODULE_IDLE = 0x0,
+    MODULE_RUNNING = 0x1,
+};
+
+enum {
+    // server to client
+    CMD_INIT = 0x1,
+    CMD_DEINIT = 0x02,
+    CMD_QUERY = 0x03,
+    CMD_RUN = 0x04,
+    CMD_STOP = 0x05,
+    CMD_NV_READ = 0X06,
+    CMD_NV_WRITE = 0X07,
+    CMD_RESULT = 0x08,
+
+    // client to server
+    CMD_PRINT = 0x101,          // for display/log message
+    CMD_HELLO = 0x103,          // for display/log message
+    CMD_CTRL = 0x104,           //Diag control mmi behavior
+};
+
+typedef enum {
+    PRINT = 0,                  //only print in screen
+    DATA,                       //only save data in file
+    PRINT_DATA,                 //print in screen and save data
+} print_type_t;
+
+/**MMI test mode*/
+typedef enum {
+    TEST_MODE_NONE = 0,
+    TEST_MODE_PCBA = 1,
+    TEST_MODE_UI = 2,
+    MAX_TEST_MODE
+} module_mode_t;
+
+/*
+ * communication header between process
+ * */
+typedef enum {
+    BUF_STATE_EMPTY,
+    BUF_STATE_DONE
+} buffer_state_t;
+
+/*
+ * communication message between mmi core and client
+ * */
+typedef struct {
+    char module[64];
+    int msg_id;
+    int cmd;
+    char subcmd[32];
+    int length;
+    int result;
+    char msg[SIZE_1K];          //para:xxx;  capture:normal:para
+} __attribute__ ((__packed__)) msg_t;
+
+/**Queue List*/
+typedef struct {
+    list < msg_t * >queue;
+    pthread_mutex_t lock;
+} msg_queue_t;
+
+typedef struct {
+    bool is_valid;
+    uint32_t size;
+      list < string > cmd_list;
+} extra_cmd_t;
+
+class module_info {
+  public:
+    char module[64];
+    int socket_fd;
+    int result;
+    pid_t pid;
+    int mode;
+    int running_state;
+    extra_cmd_t extracmd;
+    time_t start_time;          //start test time
+    double duration;            //test duration
+    time_t last_time;           //last time to modify test result data
+    char data[SIZE_512];        //module test data
+
+      unordered_map < string, string > config_list;
+      module_info(char *mod) {
+        if(mod != NULL)
+            strlcpy(module, mod, sizeof(module));
+
+        memset(data, 0, sizeof(data));
+        result = INT_MAX;
+        pid = -1;
+        socket_fd = -1;
+        extracmd.is_valid = false;
+        running_state = MODULE_IDLE;
+    }
+};
+
+typedef struct {
+    cb_t cb;
+    void *module;
+} runnable_t;
+
+typedef struct {
+    list < runnable_t * >queue;
+    pthread_mutex_t lock;
+} runnable_queue_t;
+
+typedef struct {
+    union {
+        struct {
+            char r;
+            char g;
+            char b;
+            char a;
+        };
+        int32_t color;
+    };
+} color_t;
+
+typedef struct {
+    int x;
+    int y;
+    int w;
+    int h;
+} rect_t;
+
+typedef struct {
+    char name[32];
+    cb_t cb;
+} func_map_t;
+
+#define PRESS_SHAKE_X 10
+#define PRESS_SHAKE_Y 10
+
+typedef struct {
+    int x_max;
+    int x_min;
+    int y_max;
+    int y_min;
+} touch_xy_min_max_t;
+
+class point_t {
+  public:
+    int x;
+    int y;
+    timeval tv;                 //receive time
+
+      point_t() {
+    }
+    point_t(int x, int y) {
+        this->x = x;
+        this->y = y;
+    }
+    void operator=(const point_t & point) {
+        this->x = point.x;
+        this->y = point.y;
+        this->tv = point.tv;
+    }
+
+    bool operator==(const point_t & point) {
+        if(this->x == point.x && this->y == point.y)
+            return true;
+        return false;
+    }
+};
+
+
+/**************************/
+class mutex_locker {
+    pthread_mutex_t m_mutex;
+  public:
+      class autolock {
+        mutex_locker & locker;
+      public:
+        inline autolock(mutex_locker & locker):locker(locker) {
+            locker.lock();
+        }
+        inline ~ autolock() {
+            locker.unlock();
+        }
+    };
+    inline mutex_locker() {
+        pthread_mutex_init(&m_mutex, 0);
+    }
+    inline ~ mutex_locker() {
+        pthread_mutex_destroy(&m_mutex);
+    }
+    inline void lock() {
+        pthread_mutex_lock(&m_mutex);
+    }
+    inline void unlock() {
+        pthread_mutex_unlock(&m_mutex);
+    }
+};
+
+typedef struct exec_cmd_t {
+    const char *cmd;
+    char **params;
+    char *result;
+    char *exit_str;
+    int pid;
+    int size;
+} exec_cmd_t;
+
+typedef void (*callback) (char *, int);
+
+typedef struct {
+    const char *key_name;
+    class button *key_btn;
+    int key_code;
+    bool exist;
+    bool tested;
+} key_map_t;
+
+typedef struct {
+    class module_info *mod;
+    struct input_event *ev;
+} mod_ev_t;
+
+#endif
diff --git a/src/plugins/platforms/androidmini/main.cpp b/src/plugins/platforms/androidmini/main.cpp
new file mode 100755
index 0000000..5d12f5d
--- /dev/null
+++ b/src/plugins/platforms/androidmini/main.cpp
@@ -0,0 +1,65 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qpa/qplatformintegrationplugin.h>
+#include "qlinuxfbintegration.h"
+
+QT_BEGIN_NAMESPACE
+
+class QLinuxFbIntegrationPlugin : public QPlatformIntegrationPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID QPlatformIntegrationFactoryInterface_iid FILE "androidmini.json")
+public:
+    QPlatformIntegration *create(const QString&, const QStringList&) Q_DECL_OVERRIDE;
+};
+
+QPlatformIntegration* QLinuxFbIntegrationPlugin::create(const QString& system, const QStringList& paramList)
+{
+    Q_UNUSED(paramList);
+    if (!system.compare(QLatin1String("androidmini"), Qt::CaseInsensitive))
+        return new QLinuxFbIntegration(paramList);
+
+    return 0;
+}
+
+QT_END_NAMESPACE
+
+#include "main.moc"
+
diff --git a/src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.cpp b/src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.cpp
new file mode 100755
index 0000000..e1dcebf
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.cpp
@@ -0,0 +1,396 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidassetsfileenginehandler.h"
+#include "androidjnimain.h"
+
+#include <QCoreApplication>
+#include <QVector>
+
+QT_BEGIN_NAMESPACE
+
+typedef QVector<QString> FilesList;
+
+struct AndroidAssetDir
+{
+    AndroidAssetDir(AAssetDir* ad)
+    {
+        if (ad) {
+            const char *fileName;
+            while ((fileName = AAssetDir_getNextFileName(ad)))
+                m_items.push_back(QString::fromUtf8(fileName));
+            AAssetDir_close(ad);
+        }
+    }
+    FilesList m_items;
+};
+
+class AndroidAbstractFileEngineIterator: public QAbstractFileEngineIterator
+{
+public:
+    AndroidAbstractFileEngineIterator(QDir::Filters filters,
+                                      const QStringList &nameFilters,
+                                      QSharedPointer<AndroidAssetDir> asset,
+                                      const QString &path)
+        : QAbstractFileEngineIterator(filters, nameFilters)
+    {
+        m_items = asset->m_items;
+        m_index = -1;
+        m_path = path;
+    }
+
+    QFileInfo currentFileInfo() const override
+    {
+        return QFileInfo(currentFilePath());
+    }
+
+    QString currentFileName() const override
+    {
+        if (m_index < 0 || m_index >= m_items.size())
+            return QString();
+        QString fileName = m_items[m_index];
+        if (fileName.endsWith(QLatin1Char('/')))
+            fileName.chop(1);
+        return fileName;
+    }
+
+    virtual QString currentFilePath() const
+    {
+        return m_path + currentFileName();
+    }
+
+    bool hasNext() const override
+    {
+        return m_items.size() && (m_index < m_items.size() - 1);
+    }
+
+    QString next() override
+    {
+        if (!hasNext())
+            return QString();
+        m_index++;
+        return currentFileName();
+    }
+
+private:
+    QString     m_path;
+    FilesList   m_items;
+    int         m_index;
+};
+
+class AndroidAbstractFileEngine: public QAbstractFileEngine
+{
+public:
+    explicit AndroidAbstractFileEngine(AAsset *asset, const QString &fileName)
+    {
+        m_assetFile = asset;
+        m_fileName = fileName;
+    }
+
+    explicit AndroidAbstractFileEngine(QSharedPointer<AndroidAssetDir> asset, const QString &fileName)
+    {
+        m_assetFile = 0;
+        m_assetDir = asset;
+        m_fileName =  fileName;
+        if (!m_fileName.endsWith(QLatin1Char('/')))
+            m_fileName += QLatin1Char('/');
+    }
+
+    ~AndroidAbstractFileEngine()
+    {
+        close();
+    }
+
+    bool open(QIODevice::OpenMode openMode) override
+    {
+        return m_assetFile != 0 && (openMode & QIODevice::WriteOnly) == 0;
+    }
+
+    bool close() override
+    {
+        if (m_assetFile) {
+            AAsset_close(m_assetFile);
+            m_assetFile = 0;
+            return true;
+        }
+        return false;
+    }
+
+    qint64 size() const override
+    {
+        if (m_assetFile)
+            return AAsset_getLength(m_assetFile);
+        return -1;
+    }
+
+    qint64 pos() const override
+    {
+        if (m_assetFile)
+            return AAsset_seek(m_assetFile, 0, SEEK_CUR);
+        return -1;
+    }
+
+    bool seek(qint64 pos) override
+    {
+        if (m_assetFile)
+            return pos == AAsset_seek(m_assetFile, pos, SEEK_SET);
+        return false;
+    }
+
+    qint64 read(char *data, qint64 maxlen) override
+    {
+        if (m_assetFile)
+            return AAsset_read(m_assetFile, data, maxlen);
+        return -1;
+    }
+
+    bool isSequential() const override
+    {
+        return false;
+    }
+
+    bool caseSensitive() const override
+    {
+        return true;
+    }
+
+    bool isRelativePath() const override
+    {
+        return false;
+    }
+
+    FileFlags fileFlags(FileFlags type = FileInfoAll) const override
+    {
+        FileFlags flags(ReadOwnerPerm|ReadUserPerm|ReadGroupPerm|ReadOtherPerm|ExistsFlag);
+        if (m_assetFile)
+            flags |= FileType;
+        if (!m_assetDir.isNull())
+            flags |= DirectoryType;
+
+        return type & flags;
+    }
+
+    QString fileName(FileName file = DefaultName) const override
+    {
+        int pos;
+        switch (file) {
+        case DefaultName:
+        case AbsoluteName:
+        case CanonicalName:
+                return m_fileName;
+        case BaseName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.mid(pos);
+            else
+                return m_fileName;
+        case PathName:
+        case AbsolutePathName:
+        case CanonicalPathName:
+            if ((pos = m_fileName.lastIndexOf(QChar(QLatin1Char('/')))) != -1)
+                return m_fileName.left(pos);
+            else
+                return m_fileName;
+        default:
+            return QString();
+        }
+    }
+
+    void setFileName(const QString &file) override
+    {
+        if (file == m_fileName)
+            return;
+
+        m_fileName = file;
+        if (!m_fileName.endsWith(QLatin1Char('/')))
+            m_fileName += QLatin1Char('/');
+
+        close();
+    }
+
+    Iterator *beginEntryList(QDir::Filters filters, const QStringList &filterNames) override
+    {
+        if (!m_assetDir.isNull())
+            return new AndroidAbstractFileEngineIterator(filters, filterNames, m_assetDir, m_fileName);
+        return 0;
+    }
+
+private:
+    AAsset *m_assetFile;
+    QSharedPointer<AndroidAssetDir> m_assetDir;
+    QString m_fileName;
+};
+
+
+AndroidAssetsFileEngineHandler::AndroidAssetsFileEngineHandler()
+    : m_assetsCache(std::max(5, qEnvironmentVariableIntValue("QT_ANDROID_MAX_ASSETS_CACHE_SIZE")))
+    , m_hasPrepopulatedCache(false)
+    , m_hasTriedPrepopulatingCache(false)
+{
+    m_assetManager = QtAndroid::assetManager();
+}
+
+AndroidAssetsFileEngineHandler::~AndroidAssetsFileEngineHandler()
+{
+}
+
+void AndroidAssetsFileEngineHandler::prepopulateCache() const
+{
+    Q_ASSERT(!m_hasTriedPrepopulatingCache);
+    m_hasTriedPrepopulatingCache = true;
+
+    Q_ASSERT(m_assetsCache.isEmpty());
+
+    // Failsafe: Don't read cache files that are larger than 1MB
+    static qint64 maxPrepopulatedCacheSize = qMax(1024LL * 1024LL,
+                                                  qgetenv("QT_ANDROID_MAX_PREPOPULATED_ASSETS_CACHE_SIZE").toLongLong());
+
+    const char *fileName = "--Added-by-androiddeployqt--/qt_cache_pregenerated_file_list";
+    AAsset *asset = AAssetManager_open(m_assetManager, fileName, AASSET_MODE_BUFFER);
+    if (asset) {
+        m_hasPrepopulatedCache = true;
+        AndroidAbstractFileEngine fileEngine(asset, QString::fromLatin1(fileName));
+        if (fileEngine.open(QIODevice::ReadOnly)) {
+            qint64 size = fileEngine.size();
+
+            if (size <= maxPrepopulatedCacheSize) {
+                QByteArray bytes(size, Qt::Uninitialized);
+                qint64 read = fileEngine.read(bytes.data(), size);
+                if (read != size) {
+                    qWarning("Failed to read prepopulated cache");
+                    return;
+                }
+
+                QDataStream stream(&bytes, QIODevice::ReadOnly);
+                stream.setVersion(QDataStream::Qt_5_3);
+                if (stream.status() != QDataStream::Ok) {
+                    qWarning("Failed to read prepopulated cache");
+                    return;
+                }
+
+                while (!stream.atEnd()) {
+                    QString directoryName;
+                    stream >> directoryName;
+
+                    int fileCount;
+                    stream >> fileCount;
+
+                    QVector<QString> fileList;
+                    fileList.reserve(fileCount);
+                    while (fileCount--) {
+                        QString fileName;
+                        stream >> fileName;
+                        fileList.append(fileName);
+                    }
+
+                    QSharedPointer<AndroidAssetDir> *aad = new QSharedPointer<AndroidAssetDir>(new AndroidAssetDir(0));
+                    (*aad)->m_items = fileList;
+
+                    // Cost = 0, because we should always cache everything if there's a prepopulated cache
+                    QByteArray key = directoryName != QLatin1String("/")
+                            ? QByteArray("assets:/") + directoryName.toUtf8()
+                            : QByteArray("assets:");
+
+                    bool ok = m_assetsCache.insert(key, aad, 0);
+                    if (!ok)
+                        qWarning("Failed to insert in cache: %s", qPrintable(directoryName));
+                }
+            } else {
+                qWarning("Prepopulated cache is too large to read.\n"
+                         "Use environment variable QT_ANDROID_MAX_PREPOPULATED_ASSETS_CACHE_SIZE to adjust size.");
+            }
+        }
+    }
+}
+
+QAbstractFileEngine * AndroidAssetsFileEngineHandler::create(const QString &fileName) const
+{
+    if (fileName.isEmpty())
+        return 0;
+
+    static QLatin1String assetsPrefix("assets:");
+    if (!fileName.startsWith(assetsPrefix))
+        return 0;
+
+    static int prefixSize = assetsPrefix.size() + 1;
+
+    QByteArray path;
+    if (!fileName.endsWith(QLatin1Char('/'))) {
+        path = fileName.toUtf8();
+        if (path.size() > prefixSize) {
+            AAsset *asset = AAssetManager_open(m_assetManager,
+                                               path.constData() + prefixSize,
+                                               AASSET_MODE_BUFFER);
+            if (asset)
+                return new AndroidAbstractFileEngine(asset, fileName);
+        }
+    }
+
+    if (!path.size())
+         path = fileName.left(fileName.length() - 1).toUtf8();
+
+
+    m_assetsCacheMutext.lock();
+    if (!m_hasTriedPrepopulatingCache)
+        prepopulateCache();
+
+    QSharedPointer<AndroidAssetDir> *aad = m_assetsCache.object(path);
+    m_assetsCacheMutext.unlock();
+    if (!aad) {
+        if (!m_hasPrepopulatedCache && path.size() > prefixSize) {
+            AAssetDir *assetDir = AAssetManager_openDir(m_assetManager, path.constData() + prefixSize);
+            if (assetDir) {
+                if (AAssetDir_getNextFileName(assetDir)) {
+                    AAssetDir_rewind(assetDir);
+                    aad = new QSharedPointer<AndroidAssetDir>(new AndroidAssetDir(assetDir));
+                    m_assetsCacheMutext.lock();
+                    m_assetsCache.insert(path, aad);
+                    m_assetsCacheMutext.unlock();
+                    return new AndroidAbstractFileEngine(*aad, fileName);
+                } else {
+                    AAssetDir_close(assetDir);
+                }
+            }
+        }
+    } else {
+        return new AndroidAbstractFileEngine(*aad, fileName);
+    }
+    return 0;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.h b/src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.h
new file mode 100755
index 0000000..f99dc9a
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidassetsfileenginehandler.h
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDASSETSFILEENGINEHANDLER_H
+#define QANDROIDASSETSFILEENGINEHANDLER_H
+
+#include <QtCore/private/qabstractfileengine_p.h>
+#include <QCache>
+#include <QMutex>
+#include <QSharedPointer>
+
+#include <android/asset_manager.h>
+
+QT_BEGIN_NAMESPACE
+
+struct AndroidAssetDir;
+class AndroidAssetsFileEngineHandler: public QAbstractFileEngineHandler
+{
+public:
+    AndroidAssetsFileEngineHandler();
+    virtual ~AndroidAssetsFileEngineHandler();
+    QAbstractFileEngine *create(const QString &fileName) const override;
+
+private:
+    void prepopulateCache() const;
+
+    AAssetManager *m_assetManager;
+    mutable QCache<QByteArray, QSharedPointer<AndroidAssetDir>> m_assetsCache;
+    mutable QMutex m_assetsCacheMutext;
+    mutable bool m_hasPrepopulatedCache;
+    mutable bool m_hasTriedPrepopulatingCache;
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDASSETSFILEENGINEHANDLER_H
diff --git a/src/plugins/platforms/androidmini/qandroideventdispatcher.cpp b/src/plugins/platforms/androidmini/qandroideventdispatcher.cpp
new file mode 100755
index 0000000..de4a7e2
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroideventdispatcher.cpp
@@ -0,0 +1,145 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroideventdispatcher.h"
+//#include "androidjnimain.h"
+#include "androiddeadlockprotector.h"
+
+QAndroidEventDispatcher::QAndroidEventDispatcher(QObject *parent) :
+    QUnixEventDispatcherQPA(parent)
+{
+    //if (QtAndroid::blockEventLoopsWhenSuspended())  //modify by chapin
+        QAndroidEventDispatcherStopper::instance()->addEventDispatcher(this);
+}
+
+QAndroidEventDispatcher::~QAndroidEventDispatcher()
+{
+    //if (QtAndroid::blockEventLoopsWhenSuspended())  //modify by chapin
+        QAndroidEventDispatcherStopper::instance()->removeEventDispatcher(this);
+}
+
+enum States {Running = 0, StopRequest = 1, Stopping = 2};
+
+void QAndroidEventDispatcher::start()
+{
+    int prevState = m_stopRequest.fetchAndStoreAcquire(Running);
+    if (prevState == Stopping) {
+        m_semaphore.release();
+        wakeUp();
+    } else if (prevState == Running) {
+        qWarning("Error: start without corresponding stop");
+    }
+    //else if prevState == StopRequest, no action needed
+}
+
+void QAndroidEventDispatcher::stop()
+{
+    if (m_stopRequest.testAndSetAcquire(Running, StopRequest))
+        wakeUp();
+    else
+        qWarning("Error: start/stop out of sync");
+}
+
+void QAndroidEventDispatcher::goingToStop(bool stop)
+{
+    m_goingToStop.store(stop ? 1 : 0);
+    if (!stop)
+        wakeUp();
+}
+
+bool QAndroidEventDispatcher::processEvents(QEventLoop::ProcessEventsFlags flags)
+{
+    if (m_goingToStop.load())
+        flags |= QEventLoop::ExcludeSocketNotifiers | QEventLoop::X11ExcludeTimers;
+
+    {
+        /*AndroidDeadlockProtector protector;   //modify by chapin
+        if (protector.acquire() && m_stopRequest.testAndSetAcquire(StopRequest, Stopping)) {
+            m_semaphore.acquire();
+            wakeUp();
+        }*/
+    }
+
+    return QUnixEventDispatcherQPA::processEvents(flags);
+}
+
+QAndroidEventDispatcherStopper *QAndroidEventDispatcherStopper::instance()
+{
+    static QAndroidEventDispatcherStopper androidEventDispatcherStopper;
+    return &androidEventDispatcherStopper;
+}
+
+void QAndroidEventDispatcherStopper::startAll()
+{
+    QMutexLocker lock(&m_mutex);
+    if (!m_started.testAndSetOrdered(0, 1))
+        return;
+
+    for (QAndroidEventDispatcher *d : qAsConst(m_dispatchers))
+        d->start();
+}
+
+void QAndroidEventDispatcherStopper::stopAll()
+{
+    QMutexLocker lock(&m_mutex);
+    if (!m_started.testAndSetOrdered(1, 0))
+        return;
+
+    for (QAndroidEventDispatcher *d : qAsConst(m_dispatchers))
+        d->stop();
+}
+
+void QAndroidEventDispatcherStopper::addEventDispatcher(QAndroidEventDispatcher *dispatcher)
+{
+    QMutexLocker lock(&m_mutex);
+    m_dispatchers.push_back(dispatcher);
+}
+
+void QAndroidEventDispatcherStopper::removeEventDispatcher(QAndroidEventDispatcher *dispatcher)
+{
+    QMutexLocker lock(&m_mutex);
+    m_dispatchers.erase(std::find(m_dispatchers.begin(), m_dispatchers.end(), dispatcher));
+}
+
+void QAndroidEventDispatcherStopper::goingToStop(bool stop)
+{
+    QMutexLocker lock(&m_mutex);
+    for (QAndroidEventDispatcher *d : qAsConst(m_dispatchers))
+        d->goingToStop(stop);
+}
diff --git a/src/plugins/platforms/androidmini/qandroideventdispatcher.h b/src/plugins/platforms/androidmini/qandroideventdispatcher.h
new file mode 100755
index 0000000..e6f903b
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroideventdispatcher.h
@@ -0,0 +1,85 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDEVENTDISPATCHER_H
+#define QANDROIDEVENTDISPATCHER_H
+
+#include <QtCore/QMutex>
+#include <QtCore/QSemaphore>
+#include <QtEventDispatcherSupport/private/qunixeventdispatcher_qpa_p.h>
+
+class QAndroidEventDispatcher : public QUnixEventDispatcherQPA
+{
+    Q_OBJECT
+public:
+    explicit QAndroidEventDispatcher(QObject *parent = 0);
+    ~QAndroidEventDispatcher();
+    void start();
+    void stop();
+
+    void goingToStop(bool stop);
+
+protected:
+    bool processEvents(QEventLoop::ProcessEventsFlags flags) override;
+
+private:
+    QAtomicInt m_stopRequest;
+    QAtomicInt m_goingToStop;
+    QSemaphore m_semaphore;
+};
+
+class QAndroidEventDispatcherStopper
+{
+public:
+    static QAndroidEventDispatcherStopper *instance();
+    static bool stopped() {return !instance()->m_started.load(); }
+    void startAll();
+    void stopAll();
+    void addEventDispatcher(QAndroidEventDispatcher *dispatcher);
+    void removeEventDispatcher(QAndroidEventDispatcher *dispatcher);
+    void goingToStop(bool stop);
+
+private:
+    QMutex m_mutex;
+    QAtomicInt m_started = 1;
+    QVector<QAndroidEventDispatcher *> m_dispatchers;
+};
+
+
+#endif // QANDROIDEVENTDISPATCHER_H
diff --git a/src/plugins/platforms/androidmini/qandroidinputcontext.h b/src/plugins/platforms/androidmini/qandroidinputcontext.h
new file mode 100755
index 0000000..96e7f9d
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidinputcontext.h
@@ -0,0 +1,160 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 Olivier Goffart <ogoffart@woboq.com>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef ANDROIDINPUTCONTEXT_H
+#define ANDROIDINPUTCONTEXT_H
+
+#include <qpa/qplatforminputcontext.h>
+#include <qevent.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidInputContext: public QPlatformInputContext
+{
+    Q_OBJECT
+    enum CapsMode
+    {
+        CAP_MODE_CHARACTERS = 0x00001000,
+        CAP_MODE_SENTENCES  = 0x00004000,
+        CAP_MODE_WORDS      = 0x00002000
+    };
+
+public:
+    struct ExtractedText
+    {
+        ExtractedText() { clear(); }
+
+        void clear()
+        {
+            partialEndOffset = partialStartOffset = selectionEnd = selectionStart = startOffset = -1;
+            text.clear();
+        }
+
+        int partialEndOffset;
+        int partialStartOffset;
+        int selectionEnd;
+        int selectionStart;
+        int startOffset;
+        QString text;
+    };
+
+public:
+    QAndroidInputContext();
+    ~QAndroidInputContext();
+    static QAndroidInputContext * androidInputContext();
+    bool isValid() const override { return true; }
+
+    void reset() override;
+    void commit() override;
+    void update(Qt::InputMethodQueries queries) override;
+    void invokeAction(QInputMethod::Action action, int cursorPosition) override;
+    QRectF keyboardRect() const override;
+    bool isAnimating() const override;
+    void showInputPanel() override;
+    void hideInputPanel() override;
+    bool isInputPanelVisible() const override;
+
+    bool isComposing() const;
+    void clear();
+    void setFocusObject(QObject *object) override;
+    void sendShortcut(const QKeySequence &);
+
+    //---------------//
+    jboolean beginBatchEdit();
+    jboolean endBatchEdit();
+    jboolean commitText(const QString &text, jint newCursorPosition);
+    jboolean deleteSurroundingText(jint leftLength, jint rightLength);
+    jboolean finishComposingText();
+    jint getCursorCapsMode(jint reqModes);
+    const ExtractedText &getExtractedText(jint hintMaxChars, jint hintMaxLines, jint flags);
+    QString getSelectedText(jint flags);
+    QString getTextAfterCursor(jint length, jint flags);
+    QString getTextBeforeCursor(jint length, jint flags);
+    jboolean setComposingText(const QString &text, jint newCursorPosition);
+    jboolean setComposingRegion(jint start, jint end);
+    jboolean setSelection(jint start, jint end);
+    jboolean selectAll();
+    jboolean cut();
+    jboolean copy();
+    jboolean copyURL();
+    jboolean paste();
+
+public slots:
+    void updateCursorPosition();
+    void updateSelectionHandles();
+    void handleLocationChanged(int handleId, int x, int y);
+    void touchDown(int x, int y);
+    void longPress(int x, int y);
+    void keyDown();
+
+private slots:
+    void showInputPanelLater(Qt::ApplicationState);
+
+private:
+    void sendInputMethodEventThreadSafe(QInputMethodEvent *event);
+    Q_INVOKABLE void sendInputMethodEventUnsafe(QInputMethodEvent *event);
+
+    QSharedPointer<QInputMethodQueryEvent> focusObjectInputMethodQueryThreadSafe(Qt::InputMethodQueries queries = Qt::ImQueryAll);
+    Q_INVOKABLE QInputMethodQueryEvent *focusObjectInputMethodQueryUnsafe(Qt::InputMethodQueries queries);
+
+    Q_INVOKABLE QVariant queryFocusObjectUnsafe(Qt::InputMethodQuery query, QVariant argument);
+    QVariant queryFocusObjectThreadSafe(Qt::InputMethodQuery query, QVariant argument);
+
+private:
+    ExtractedText m_extractedText;
+    QString m_composingText;
+    int m_composingTextStart;
+    int m_composingCursor;
+    QMetaObject::Connection m_updateCursorPosConnection;
+    bool m_blockUpdateSelection;
+    enum CursorHandleShowMode {
+        CursorHandleNotShown,
+        CursorHandleShowNormal = 1,
+        CursorHandleShowSelection = 2,
+        CursorHandleShowPopup = 3
+    };
+    CursorHandleShowMode m_cursorHandleShown;
+    QAtomicInt m_batchEditNestingLevel;
+    QObject *m_focusObject;
+};
+
+QT_END_NAMESPACE
+
+#endif // ANDROIDINPUTCONTEXT_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformaccessibility.cpp b/src/plugins/platforms/androidmini/qandroidplatformaccessibility.cpp
new file mode 100755
index 0000000..fdff9c3
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformaccessibility.cpp
@@ -0,0 +1,59 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#include "qandroidplatformaccessibility.h"
+#include "androidjniaccessibility.h"
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformAccessibility::QAndroidPlatformAccessibility()
+{
+    QtAndroidAccessibility::initialize();
+}
+
+QAndroidPlatformAccessibility::~QAndroidPlatformAccessibility()
+{}
+
+void QAndroidPlatformAccessibility::notifyAccessibilityUpdate(QAccessibleEvent */*event*/)
+{
+    // FIXME send events
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformaccessibility.h b/src/plugins/platforms/androidmini/qandroidplatformaccessibility.h
new file mode 100755
index 0000000..8216c05
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformaccessibility.h
@@ -0,0 +1,59 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QANDROIDPLATFORMACCESSIBILITY_H
+#define QANDROIDPLATFORMACCESSIBILITY_H
+
+#include <qpa/qplatformaccessibility.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformAccessibility: public QPlatformAccessibility
+{
+public:
+    QAndroidPlatformAccessibility();
+    ~QAndroidPlatformAccessibility();
+
+    void notifyAccessibilityUpdate(QAccessibleEvent *event) override;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/platforms/androidmini/qandroidplatformbackingstore.cpp b/src/plugins/platforms/androidmini/qandroidplatformbackingstore.cpp
new file mode 100755
index 0000000..fb6209b
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformbackingstore.cpp
@@ -0,0 +1,93 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifdef USE_LINUXFB
+#include "qlinuxfbscreen.h"
+#else
+#include "qandroidplatformscreen.h"
+#endif
+
+#include "qandroidplatformbackingstore.h"
+#include "qandroidplatformwindow.h"
+#include <qpa/qplatformscreen.h>
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformBackingStore::QAndroidPlatformBackingStore(QWindow *window)
+    : QPlatformBackingStore(window)
+{
+    if (window->handle())
+        setBackingStore(window);
+}
+
+QPaintDevice *QAndroidPlatformBackingStore::paintDevice()
+{
+    return &m_image;
+}
+
+void QAndroidPlatformBackingStore::flush(QWindow *window, const QRegion &region, const QPoint &offset)
+{
+    Q_UNUSED(offset);
+
+    if (!m_backingStoreSet)
+        setBackingStore(window);
+
+    (static_cast<QAndroidPlatformWindow *>(window->handle()))->repaint(region);
+}
+
+void QAndroidPlatformBackingStore::resize(const QSize &size, const QRegion &staticContents)
+{
+    Q_UNUSED(staticContents);
+
+    if (m_image.size() != size)
+        m_image = QImage(size, window()->screen()->handle()->format());
+}
+
+void QAndroidPlatformBackingStore::setBackingStore(QWindow *window)
+{
+    if (window->surfaceType() == QSurface::RasterSurface || window->surfaceType() == QSurface::RasterGLSurface) {
+        (static_cast<QAndroidPlatformWindow *>(window->handle()))->setBackingStore(this);
+        m_backingStoreSet = true;
+    } else {
+        qWarning("QAndroidPlatformBackingStore does not support OpenGL-only windows.");
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformbackingstore.h b/src/plugins/platforms/androidmini/qandroidplatformbackingstore.h
new file mode 100755
index 0000000..a3a65aa
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformbackingstore.h
@@ -0,0 +1,65 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMBACKINGSTORE_H
+#define QANDROIDPLATFORMBACKINGSTORE_H
+
+#include <qpa/qplatformbackingstore.h>
+#include <qpa/qwindowsysteminterface.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformBackingStore : public QPlatformBackingStore
+{
+public:
+    explicit QAndroidPlatformBackingStore(QWindow *window);
+    QPaintDevice *paintDevice() override;
+    void flush(QWindow *window, const QRegion &region, const QPoint &offset) override;
+    void resize(const QSize &size, const QRegion &staticContents) override;
+    QImage toImage() const override { return m_image; }
+    void setBackingStore(QWindow *window);
+protected:
+    QImage m_image;
+    bool m_backingStoreSet = false;
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMBACKINGSTORE_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformclipboard.cpp b/src/plugins/platforms/androidmini/qandroidplatformclipboard.cpp
new file mode 100755
index 0000000..dc5147b
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformclipboard.cpp
@@ -0,0 +1,76 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidplatformclipboard.h"
+#include "androidjniclipboard.h"
+#ifndef QT_NO_CLIPBOARD
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformClipboard::QAndroidPlatformClipboard()
+{
+    QtAndroidClipboard::setClipboardManager(this);
+}
+
+QMimeData *QAndroidPlatformClipboard::mimeData(QClipboard::Mode mode)
+{
+    Q_UNUSED(mode);
+    Q_ASSERT(supportsMode(mode));
+    m_mimeData.setText(QtAndroidClipboard::hasClipboardText()
+                       ? QtAndroidClipboard::clipboardText()
+                       : QString());
+    return &m_mimeData;
+}
+
+void QAndroidPlatformClipboard::setMimeData(QMimeData *data, QClipboard::Mode mode)
+{
+    if (supportsMode(mode))
+        QtAndroidClipboard::setClipboardText(data != 0 && data->hasText() ? data->text() : QString());
+    if (data != 0)
+        data->deleteLater();
+}
+
+bool QAndroidPlatformClipboard::supportsMode(QClipboard::Mode mode) const
+{
+    return QClipboard::Clipboard == mode;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_CLIPBOARD
diff --git a/src/plugins/platforms/androidmini/qandroidplatformclipboard.h b/src/plugins/platforms/androidmini/qandroidplatformclipboard.h
new file mode 100755
index 0000000..dfc3629
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformclipboard.h
@@ -0,0 +1,65 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMCLIPBOARD_H
+#define QANDROIDPLATFORMCLIPBOARD_H
+
+#include <qpa/qplatformclipboard.h>
+#include <QMimeData>
+
+#ifndef QT_NO_CLIPBOARD
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformClipboard: public QPlatformClipboard
+{
+public:
+    QAndroidPlatformClipboard();
+
+    QMimeData *mimeData(QClipboard::Mode mode = QClipboard::Clipboard) override;
+    void setMimeData(QMimeData *data, QClipboard::Mode mode = QClipboard::Clipboard) override;
+    bool supportsMode(QClipboard::Mode mode) const override;
+
+private:
+    QMimeData m_mimeData;
+};
+
+QT_END_NAMESPACE
+#endif // QT_NO_CLIPBOARD
+
+#endif // QANDROIDPLATFORMCLIPBOARD_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.cpp b/src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.cpp
new file mode 100755
index 0000000..08498d0
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.cpp
@@ -0,0 +1,193 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidplatformdialoghelpers.h"
+#include "androidjnimain.h"
+
+#include <QTextDocument>
+
+#include <private/qguiapplication_p.h>
+#include <qpa/qplatformtheme.h>
+
+QT_BEGIN_NAMESPACE
+
+namespace QtAndroidDialogHelpers {
+static jclass g_messageDialogHelperClass = 0;
+
+static const char QtMessageHandlerHelperClassName[] = "org/qtproject/qt5/android/QtMessageDialogHelper";
+
+QAndroidPlatformMessageDialogHelper::QAndroidPlatformMessageDialogHelper()
+    :m_buttonId(-1)
+    ,m_javaMessageDialog(g_messageDialogHelperClass, "(Landroid/app/Activity;)V", QtAndroid::activity())
+    ,m_shown(false)
+{
+}
+
+void QAndroidPlatformMessageDialogHelper::exec()
+{
+    if (!m_shown)
+        show(Qt::Dialog, Qt::ApplicationModal, 0);
+    m_loop.exec();
+}
+
+static QString htmlText(QString text)
+{
+    if (Qt::mightBeRichText(text))
+        return text;
+    text.remove(QLatin1Char('\r'));
+    return text.toHtmlEscaped().replace(QLatin1Char('\n'), QLatin1String("<br />"));
+}
+
+bool QAndroidPlatformMessageDialogHelper::show(Qt::WindowFlags windowFlags
+                                         , Qt::WindowModality windowModality
+                                         , QWindow *parent)
+{
+    Q_UNUSED(windowFlags)
+    Q_UNUSED(windowModality)
+    Q_UNUSED(parent)
+    QSharedPointer<QMessageDialogOptions> opt = options();
+    if (!opt.data())
+        return false;
+
+    m_javaMessageDialog.callMethod<void>("setIcon", "(I)V", opt->icon());
+
+    QString str = htmlText(opt->windowTitle());
+    if (!str.isEmpty())
+        m_javaMessageDialog.callMethod<void>("setTile", "(Ljava/lang/String;)V", QJNIObjectPrivate::fromString(str).object());
+
+    str = htmlText(opt->text());
+    if (!str.isEmpty())
+        m_javaMessageDialog.callMethod<void>("setText", "(Ljava/lang/String;)V", QJNIObjectPrivate::fromString(str).object());
+
+    str = htmlText(opt->informativeText());
+    if (!str.isEmpty())
+        m_javaMessageDialog.callMethod<void>("setInformativeText", "(Ljava/lang/String;)V", QJNIObjectPrivate::fromString(str).object());
+
+    str = htmlText(opt->detailedText());
+    if (!str.isEmpty())
+        m_javaMessageDialog.callMethod<void>("setDetailedText", "(Ljava/lang/String;)V", QJNIObjectPrivate::fromString(str).object());
+
+    // http://developer.android.com/design/building-blocks/dialogs.html
+    // dismissive action on the left, affirmative on the right
+    // There don't seem to be more fine-grained rules, but the OS X layout
+    // at least conforms to this one rule and makes the rest deterministic.
+    const int * currentLayout = buttonLayout(Qt::Horizontal, MacLayout);
+    while (*currentLayout != QPlatformDialogHelper::EOL) {
+        int role = (*currentLayout & ~QPlatformDialogHelper::Reverse);
+        addButtons(opt, static_cast<ButtonRole>(role));
+        ++currentLayout;
+    }
+
+    m_javaMessageDialog.callMethod<void>("show", "(J)V", jlong(static_cast<QObject*>(this)));
+    m_shown = true;
+    return true;
+}
+
+void QAndroidPlatformMessageDialogHelper::addButtons(QSharedPointer<QMessageDialogOptions> opt, ButtonRole role)
+{
+    for (int i = QPlatformDialogHelper::FirstButton; i < QPlatformDialogHelper::LastButton; i<<=1) {
+        StandardButton b = static_cast<StandardButton>(i);
+        if (buttonRole(b) == role && (opt->standardButtons() & i)) {
+            const QString text = QGuiApplicationPrivate::platformTheme()->standardButtonText(b);
+            m_javaMessageDialog.callMethod<void>("addButton", "(ILjava/lang/String;)V", i, QJNIObjectPrivate::fromString(text).object());
+        }
+    }
+}
+
+void QAndroidPlatformMessageDialogHelper::hide()
+{
+    m_javaMessageDialog.callMethod<void>("hide", "()V");
+    m_shown = false;
+}
+
+void QAndroidPlatformMessageDialogHelper::dialogResult(int buttonID)
+{
+    m_buttonId = buttonID;
+    if (m_loop.isRunning())
+        m_loop.exit();
+    if (m_buttonId < 0) {
+        emit reject();
+        return;
+    }
+
+    QPlatformDialogHelper::StandardButton standardButton = static_cast<QPlatformDialogHelper::StandardButton>(buttonID);
+    QPlatformDialogHelper::ButtonRole role = QPlatformDialogHelper::buttonRole(standardButton);
+    emit clicked(standardButton, role);
+}
+
+static void dialogResult(JNIEnv * /*env*/, jobject /*thiz*/, jlong handler, int buttonID)
+{
+    QObject *object = reinterpret_cast<QObject *>(handler);
+    QMetaObject::invokeMethod(object, "dialogResult", Qt::QueuedConnection, Q_ARG(int, buttonID));
+}
+
+static JNINativeMethod methods[] = {
+    {"dialogResult", "(JI)V", (void *)dialogResult}
+};
+
+
+#define FIND_AND_CHECK_CLASS(CLASS_NAME) \
+    clazz = env->FindClass(CLASS_NAME); \
+    if (!clazz) { \
+        __android_log_print(ANDROID_LOG_FATAL, QtAndroid::qtTagText(), QtAndroid::classErrorMsgFmt(), CLASS_NAME); \
+        return false; \
+    }
+
+bool registerNatives(JNIEnv *env)
+{
+    jclass clazz = QJNIEnvironmentPrivate::findClass(QtMessageHandlerHelperClassName, env);
+    if (!clazz) {
+        __android_log_print(ANDROID_LOG_FATAL, QtAndroid::qtTagText(), QtAndroid::classErrorMsgFmt()
+                            , QtMessageHandlerHelperClassName);
+        return false;
+    }
+    g_messageDialogHelperClass = static_cast<jclass>(env->NewGlobalRef(clazz));
+    FIND_AND_CHECK_CLASS("org/qtproject/qt5/android/QtNativeDialogHelper");
+    jclass appClass = static_cast<jclass>(env->NewGlobalRef(clazz));
+
+    if (env->RegisterNatives(appClass, methods, sizeof(methods) / sizeof(methods[0])) < 0) {
+        __android_log_print(ANDROID_LOG_FATAL, "Qt", "RegisterNatives failed");
+        return false;
+    }
+
+    return true;
+}
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.h b/src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.h
new file mode 100755
index 0000000..6a83027
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformdialoghelpers.h
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMDIALOGHELPERS_H
+#define QANDROIDPLATFORMDIALOGHELPERS_H
+#include <qpa/qplatformdialoghelper.h>
+#include <QEventLoop>
+
+QT_BEGIN_NAMESPACE
+
+namespace QtAndroidDialogHelpers {
+
+class QAndroidPlatformMessageDialogHelper: public QPlatformMessageDialogHelper
+{
+    Q_OBJECT
+public:
+    QAndroidPlatformMessageDialogHelper();
+    void exec() override;
+    bool show(Qt::WindowFlags windowFlags,
+              Qt::WindowModality windowModality,
+              QWindow *parent) override;
+    void hide() override;
+
+public slots:
+    void dialogResult(int buttonID);
+
+private:
+    void addButtons(QSharedPointer<QMessageDialogOptions> opt, ButtonRole role);
+
+private:
+    int m_buttonId;
+    QEventLoop m_loop;
+    QJNIObjectPrivate m_javaMessageDialog;
+    bool m_shown;
+};
+
+
+bool registerNatives(JNIEnv *env);
+
+}
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMDIALOGHELPERS_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformfontdatabase.cpp b/src/plugins/platforms/androidmini/qandroidplatformfontdatabase.cpp
new file mode 100755
index 0000000..2fdf269
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformfontdatabase.cpp
@@ -0,0 +1,90 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QDir>
+
+#include "qandroidplatformfontdatabase.h"
+
+QT_BEGIN_NAMESPACE
+
+QString QAndroidPlatformFontDatabase::fontDir() const
+{
+    return QLatin1String("/system/fonts");
+}
+
+void QAndroidPlatformFontDatabase::populateFontDatabase()
+{
+    QString fontpath = fontDir();
+    QDir dir(fontpath);
+
+    if (Q_UNLIKELY(!dir.exists())) {
+        qFatal("QFontDatabase: Cannot find font directory %s - is Qt installed correctly?",
+               qPrintable(fontpath));
+    }
+
+    QStringList nameFilters;
+    nameFilters << QLatin1String("*.ttf")
+                << QLatin1String("*.otf")
+                << QLatin1String("*.ttc");
+
+    const auto entries = dir.entryInfoList(nameFilters, QDir::Files);
+    for (const QFileInfo &fi : entries) {
+        const QByteArray file = QFile::encodeName(fi.absoluteFilePath());
+        QFreeTypeFontDatabase::addTTFile(QByteArray(), file);
+    }
+}
+
+QStringList QAndroidPlatformFontDatabase::fallbacksForFamily(const QString &family,
+                                                             QFont::Style style,
+                                                             QFont::StyleHint styleHint,
+                                                             QChar::Script script) const
+{
+    QStringList result;
+    if (styleHint == QFont::Monospace || styleHint == QFont::Courier)
+        result.append(QString(qgetenv("QT_ANDROID_FONTS_MONOSPACE")).split(QLatin1Char(';')));
+    else if (styleHint == QFont::Serif)
+        result.append(QString(qgetenv("QT_ANDROID_FONTS_SERIF")).split(QLatin1Char(';')));
+    else
+        result.append(QString(qgetenv("QT_ANDROID_FONTS")).split(QLatin1Char(';')));
+    result.append(QFreeTypeFontDatabase::fallbacksForFamily(family, style, styleHint, script));
+
+    return result;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformfontdatabase.h b/src/plugins/platforms/androidmini/qandroidplatformfontdatabase.h
new file mode 100755
index 0000000..166a590
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformfontdatabase.h
@@ -0,0 +1,60 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMFONTDATABASE_H
+#define QANDROIDPLATFORMFONTDATABASE_H
+
+#include <QtFontDatabaseSupport/private/qfreetypefontdatabase_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformFontDatabase: public QFreeTypeFontDatabase
+{
+public:
+    QString fontDir() const override;
+    void populateFontDatabase() override;
+    QStringList fallbacksForFamily(const QString &family,
+                                   QFont::Style style,
+                                   QFont::StyleHint styleHint,
+                                   QChar::Script script) const override;
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMFONTDATABASE_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformforeignwindow.cpp b/src/plugins/platforms/androidmini/qandroidplatformforeignwindow.cpp
new file mode 100755
index 0000000..1c920c0
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformforeignwindow.cpp
@@ -0,0 +1,125 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidplatformforeignwindow.h"
+#include "androidjnimain.h"
+#include <QtCore/qvariant.h>
+#include <qpa/qwindowsysteminterface.h>
+#include <QtCore/private/qjnihelpers_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformForeignWindow::QAndroidPlatformForeignWindow(QWindow *window, WId nativeHandle)
+    : QAndroidPlatformWindow(window),
+      m_surfaceId(-1)
+{
+    m_view = reinterpret_cast<jobject>(nativeHandle);
+    if (m_view.isValid())
+        QtAndroid::setViewVisibility(m_view.object(), false);
+}
+
+QAndroidPlatformForeignWindow::~QAndroidPlatformForeignWindow()
+{
+    if (m_view.isValid())
+        QtAndroid::setViewVisibility(m_view.object(), false);
+    if (m_surfaceId != -1)
+        QtAndroid::destroySurface(m_surfaceId);
+}
+
+void QAndroidPlatformForeignWindow::lower()
+{
+    if (m_surfaceId == -1)
+        return;
+
+    QAndroidPlatformWindow::lower();
+    QtAndroid::bringChildToBack(m_surfaceId);
+}
+
+void QAndroidPlatformForeignWindow::raise()
+{
+    if (m_surfaceId == -1)
+        return;
+
+    QAndroidPlatformWindow::raise();
+    QtAndroid::bringChildToFront(m_surfaceId);
+}
+
+void QAndroidPlatformForeignWindow::setGeometry(const QRect &rect)
+{
+    QAndroidPlatformWindow::setGeometry(rect);
+
+    if (m_surfaceId != -1)
+        QtAndroid::setSurfaceGeometry(m_surfaceId, rect);
+}
+
+void QAndroidPlatformForeignWindow::setVisible(bool visible)
+{
+    if (!m_view.isValid())
+        return;
+
+    QtAndroid::setViewVisibility(m_view.object(), visible);
+
+    QAndroidPlatformWindow::setVisible(visible);
+    if (!visible && m_surfaceId != -1) {
+        QtAndroid::destroySurface(m_surfaceId);
+        m_surfaceId = -1;
+    } else if (m_surfaceId == -1) {
+        m_surfaceId = QtAndroid::insertNativeView(m_view.object(), geometry());
+    }
+}
+
+void QAndroidPlatformForeignWindow::applicationStateChanged(Qt::ApplicationState state)
+{
+    if (state <= Qt::ApplicationHidden
+            && m_surfaceId != -1) {
+        QtAndroid::destroySurface(m_surfaceId);
+        m_surfaceId = -1;
+    } else if (m_view.isValid() && m_surfaceId == -1){
+        m_surfaceId = QtAndroid::insertNativeView(m_view.object(), geometry());
+    }
+
+    QAndroidPlatformWindow::applicationStateChanged(state);
+}
+
+void QAndroidPlatformForeignWindow::setParent(const QPlatformWindow *window)
+{
+    Q_UNUSED(window);
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformforeignwindow.h b/src/plugins/platforms/androidmini/qandroidplatformforeignwindow.h
new file mode 100755
index 0000000..af1eee5
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformforeignwindow.h
@@ -0,0 +1,69 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMFOREIGNWINDOW_H
+#define QANDROIDPLATFORMFOREIGNWINDOW_H
+
+#include "androidsurfaceclient.h"
+#include "qandroidplatformwindow.h"
+#include <QtCore/private/qjni_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformForeignWindow : public QAndroidPlatformWindow
+{
+public:
+    explicit QAndroidPlatformForeignWindow(QWindow *window, WId nativeHandle);
+    ~QAndroidPlatformForeignWindow();
+    void lower() override;
+    void raise() override;
+    void setGeometry(const QRect &rect) override;
+    void setVisible(bool visible) override;
+    void applicationStateChanged(Qt::ApplicationState state) override;
+    void setParent(const QPlatformWindow *window) override;
+    bool isForeignWindow() const override { return true; }
+
+private:
+    int m_surfaceId;
+    QJNIObjectPrivate m_view;
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMFOREIGNWINDOW_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.cpp b/src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.cpp
new file mode 100755
index 0000000..c7d832e
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.cpp
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidplatformoffscreensurface.h"
+
+#include <QtGui/QOffscreenSurface>
+#include <QtEglSupport/private/qeglconvenience_p.h>
+
+#include <android/native_window.h>
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformOffscreenSurface::QAndroidPlatformOffscreenSurface(EGLDisplay display, const QSurfaceFormat &format, QOffscreenSurface *offscreenSurface)
+    : QPlatformOffscreenSurface(offscreenSurface)
+    , m_format(format)
+    , m_display(display)
+    , m_surface(EGL_NO_SURFACE)
+{
+    // Get native handle
+    ANativeWindow *surfaceTexture = (ANativeWindow*)offscreenSurface->nativeHandle();
+
+    EGLConfig config = q_configFromGLFormat(m_display, m_format, false);
+    if (config) {
+        const EGLint attributes[] = {
+            EGL_NONE
+        };
+        m_surface = eglCreateWindowSurface(m_display, config, surfaceTexture, attributes);
+    }
+}
+
+QAndroidPlatformOffscreenSurface::~QAndroidPlatformOffscreenSurface()
+{
+    eglDestroySurface(m_display, m_surface);
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.h b/src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.h
new file mode 100755
index 0000000..461f949
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformoffscreensurface.h
@@ -0,0 +1,67 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMOFFSCREENSURFACETEXTURE_H
+#define QANDROIDPLATFORMOFFSCREENSURFACETEXTURE_H
+
+#include <qpa/qplatformoffscreensurface.h>
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+class QOffscreenSurface;
+class QAndroidPlatformOffscreenSurface : public QPlatformOffscreenSurface
+{
+public:
+    QAndroidPlatformOffscreenSurface(EGLDisplay display, const QSurfaceFormat &format,
+                                            QOffscreenSurface *offscreenSurface);
+    ~QAndroidPlatformOffscreenSurface();
+
+    QSurfaceFormat format() const override { return m_format; }
+    bool isValid() const override { return m_surface != EGL_NO_SURFACE; }
+
+    EGLSurface surface() const { return m_surface; }
+private:
+    QSurfaceFormat m_format;
+    EGLDisplay m_display;
+    EGLSurface m_surface;
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMOFFSCREENSURFACETEXTURE_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformopenglcontext.cpp b/src/plugins/platforms/androidmini/qandroidplatformopenglcontext.cpp
new file mode 100755
index 0000000..31e019c
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformopenglcontext.cpp
@@ -0,0 +1,88 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidplatformopenglcontext.h"
+#include "qandroidplatformopenglwindow.h"
+#include "qlinuxfbintegration.h"
+#include "qandroidplatformoffscreensurface.h"
+
+#include <QtEglSupport/private/qeglpbuffer_p.h>
+
+#include <QSurface>
+#include <QtGui/private/qopenglcontext_p.h>
+#include <QtGui/QOffscreenSurface>
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformOpenGLContext::QAndroidPlatformOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display,
+                                                             const QVariant &nativeHandle)
+    :QEGLPlatformContext(format, share, display, nullptr, nativeHandle)
+{
+}
+
+void QAndroidPlatformOpenGLContext::swapBuffers(QPlatformSurface *surface)
+{
+    if (surface->surface()->surfaceClass() == QSurface::Window &&
+            static_cast<QAndroidPlatformOpenGLWindow *>(surface)->checkNativeSurface(eglConfig())) {
+        QEGLPlatformContext::makeCurrent(surface);
+    } //modify by chapin
+
+}
+
+bool QAndroidPlatformOpenGLContext::makeCurrent(QPlatformSurface *surface)
+{
+    return QEGLPlatformContext::makeCurrent(surface);
+}
+
+EGLSurface QAndroidPlatformOpenGLContext::eglSurfaceForPlatformSurface(QPlatformSurface *surface)
+{
+
+    if (surface->surface()->surfaceClass() == QSurface::Window) {
+        return static_cast<QAndroidPlatformOpenGLWindow *>(surface)->eglSurface(eglConfig());
+    } else {
+        auto platformOffscreenSurface = static_cast<QPlatformOffscreenSurface*>(surface);
+        if (platformOffscreenSurface->offscreenSurface()->nativeHandle())
+            return static_cast<QAndroidPlatformOffscreenSurface *>(surface)->surface();
+        else
+            return static_cast<QEGLPbuffer *>(surface)->pbuffer();
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformopenglcontext.h b/src/plugins/platforms/androidmini/qandroidplatformopenglcontext.h
new file mode 100755
index 0000000..8e65b4c
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformopenglcontext.h
@@ -0,0 +1,62 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMOPENGLCONTEXT_H
+#define QANDROIDPLATFORMOPENGLCONTEXT_H
+
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformOpenGLContext : public QEGLPlatformContext
+{
+public:
+    QAndroidPlatformOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display, const QVariant &nativeHandle);
+    void swapBuffers(QPlatformSurface *surface) override;
+    bool makeCurrent(QPlatformSurface *surface) override;
+
+private:
+    EGLSurface eglSurfaceForPlatformSurface(QPlatformSurface *surface) override;
+
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMOPENGLCONTEXT_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformopenglwindow.cpp b/src/plugins/platforms/androidmini/qandroidplatformopenglwindow.cpp
new file mode 100755
index 0000000..bf2fc18
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformopenglwindow.cpp
@@ -0,0 +1,197 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+
+#include "qandroideventdispatcher.h"
+#include "androiddeadlockprotector.h"
+#include "qandroidplatformscreen.h"
+
+#include <QSurfaceFormat>
+#include <QtGui/private/qwindow_p.h>
+
+#include <qpa/qwindowsysteminterface.h>
+#include <qpa/qplatformscreen.h>
+#include <QtEglSupport/private/qeglconvenience_p.h>
+//#include <android/native_window.h>
+//#include <android/native_window_jni.h>
+#include "qandroidplatformopenglwindow.h"
+
+QT_BEGIN_NAMESPACE
+
+#define OPENGL_WIDTH 720
+#define OPENGL_HEIGHT 1280
+//static sp<ANativeWindow> m_nativeWindow;  //only once
+static EGLSurface m_eglSurface = EGL_NO_SURFACE;
+QAndroidPlatformOpenGLWindow::QAndroidPlatformOpenGLWindow(QWindow *window, EGLDisplay display)
+    :QAndroidPlatformWindow(window), m_eglDisplay(display)
+{
+}
+
+QAndroidPlatformOpenGLWindow::~QAndroidPlatformOpenGLWindow()
+{
+    //m_surfaceWaitCondition.wakeOne();
+    lockSurface();
+    clearEgl();
+    unlockSurface();
+}
+
+void QAndroidPlatformOpenGLWindow::repaint(const QRegion &region)
+{
+    // This is only for real raster top-level windows. Stop in all other cases.
+    if ((window()->surfaceType() == QSurface::RasterGLSurface && qt_window_private(window())->compositing)
+        || window()->surfaceType() == QSurface::OpenGLSurface
+        || QAndroidPlatformWindow::parent())
+        return;
+
+    QRect currentGeometry = geometry();
+
+    QRect dirtyClient = region.boundingRect();
+    QRect dirtyRegion(currentGeometry.left() + dirtyClient.left(),
+                      currentGeometry.top() + dirtyClient.top(),
+                      dirtyClient.width(),
+                      dirtyClient.height());
+    QRect mOldGeometryLocal = m_oldGeometry;
+    m_oldGeometry = currentGeometry;
+    // If this is a move, redraw the previous location
+    if (mOldGeometryLocal != currentGeometry)
+        platformScreen()->setDirty(mOldGeometryLocal);
+    platformScreen()->setDirty(dirtyRegion);
+}
+
+void QAndroidPlatformOpenGLWindow::setGeometry(const QRect &rect)
+{
+    if (rect == geometry())
+        return;
+
+    m_oldGeometry = geometry();
+
+    QAndroidPlatformWindow::setGeometry(rect);
+
+    QRect availableGeometry = screen()->availableGeometry();
+    if (m_oldGeometry.width() == 0
+            && m_oldGeometry.height() == 0
+            && rect.width() > 0
+            && rect.height() > 0
+            && availableGeometry.width() > 0
+            && availableGeometry.height() > 0) {
+        QWindowSystemInterface::handleExposeEvent(window(), QRect(QPoint(0, 0), rect.size()));
+    }
+
+    if (rect.topLeft() != m_oldGeometry.topLeft())
+        repaint(QRegion(rect));
+}
+
+EGLSurface QAndroidPlatformOpenGLWindow::eglSurface(EGLConfig config)
+{
+    if (QAndroidEventDispatcherStopper::stopped())
+        return m_eglSurface;
+
+
+    QMutexLocker lock(&m_surfaceMutex);
+
+    if (m_eglSurface == EGL_NO_SURFACE) {
+        m_surfaceMutex.unlock();
+        checkNativeSurface(config);
+        m_surfaceMutex.lock();
+    }
+
+    return m_eglSurface;
+}
+
+bool QAndroidPlatformOpenGLWindow::checkNativeSurface(EGLConfig config)
+{
+    QMutexLocker lock(&m_surfaceMutex);
+
+    createEgl(config);
+
+    // we've create another surface, the window should be repainted
+    QRect availableGeometry = screen()->availableGeometry();
+    if (geometry().width() > 0 && geometry().height() > 0 && availableGeometry.width() > 0 && availableGeometry.height() > 0)
+        QWindowSystemInterface::handleExposeEvent(window(), QRegion(QRect(QPoint(), geometry().size())));
+    return true; // makeCurrent is needed!
+}
+
+void QAndroidPlatformOpenGLWindow::applicationStateChanged(Qt::ApplicationState state)
+{
+    QAndroidPlatformWindow::applicationStateChanged(state);
+    if (state <=  Qt::ApplicationHidden) {
+        lockSurface();
+		qDebug("application state change");
+        clearEgl();
+        unlockSurface();
+    }
+}
+
+void QAndroidPlatformOpenGLWindow::createEgl(EGLConfig config)
+{
+	int ret;
+
+	if (m_eglSurface == EGL_NO_SURFACE)
+	{
+    	//调用eglGetDisplay
+    	EGLint eglSurfaceAttribList[] = {EGL_WIDTH, OPENGL_WIDTH,
+                                   EGL_HEIGHT, OPENGL_HEIGHT,
+                                   EGL_NONE,
+                                   EGL_NONE,
+                                   EGL_NONE};
+
+    	m_eglSurface = eglCreatePbufferSurface(m_eglDisplay, config, eglSurfaceAttribList);
+	}
+}
+
+QSurfaceFormat QAndroidPlatformOpenGLWindow::format() const
+{
+    //if (m_nativeWindow == 0)
+        return window()->requestedFormat();
+    //else
+     //   return m_format;
+}
+
+void QAndroidPlatformOpenGLWindow::clearEgl()
+{
+    if (m_eglSurface != EGL_NO_SURFACE) {
+        eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+        eglDestroySurface(m_eglDisplay, m_eglSurface);
+        m_eglSurface = EGL_NO_SURFACE;
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformopenglwindow.h b/src/plugins/platforms/androidmini/qandroidplatformopenglwindow.h
new file mode 100755
index 0000000..1f25987
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformopenglwindow.h
@@ -0,0 +1,107 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMOPENGLWINDOW_H
+#define QANDROIDPLATFORMOPENGLWINDOW_H
+
+#include <ctype.h>
+#include <inttypes.h>
+#include <EGL/egl.h>
+#include <QWaitCondition>
+
+#ifndef USE_ANDROID_OPENGGL
+#define USE_ANDROID_OPENGGL
+#endif
+
+//#include <gui/ISurfaceComposer.h>
+//#include <gui/Surface.h>
+//#include <gui/SurfaceComposerClient.h>
+
+//#include <ui/DisplayInfo.h>
+//#include <gui/SurfaceControl.h>
+//#include <gui/ISurfaceComposer.h>
+//#include <gui/Surface.h>
+//#include <gui/SurfaceComposerClient.h>
+
+
+#include "androidsurfaceclient.h"
+#include "qandroidplatformwindow.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformOpenGLWindow : public QAndroidPlatformWindow, public AndroidSurfaceClient 
+{
+public:
+    explicit QAndroidPlatformOpenGLWindow(QWindow *window, EGLDisplay display);
+    ~QAndroidPlatformOpenGLWindow();
+
+    void setGeometry(const QRect &rect) override;
+    EGLSurface eglSurface(EGLConfig config);
+    QSurfaceFormat format() const override;
+
+    bool checkNativeSurface(EGLConfig config);
+
+    void applicationStateChanged(Qt::ApplicationState) override;
+
+    void repaint(const QRegion &region) override;
+
+protected:
+    void createEgl(EGLConfig config);
+    void clearEgl();
+
+private:
+    //EGLNativeWindowType m_nativeWindow = 0;
+
+	//sp<ANativeWindow> m_nativeWindow;
+ 	//EGLSurface m_eglSurface = EGL_NO_SURFACE;
+	//sp< SurfaceControl > mSurfaceControl;
+	//sp < SurfaceComposerClient > mComposerClient;
+
+    EGLDisplay m_eglDisplay = EGL_NO_DISPLAY;
+
+    int m_nativeSurfaceId = -1;
+    //QJNIObjectPrivate m_androidSurfaceObject;
+    QWaitCondition m_surfaceWaitCondition;
+    QSurfaceFormat m_format;
+    QRect m_oldGeometry;
+};
+
+QT_END_NAMESPACE
+#endif // QANDROIDPLATFORMOPENGLWINDOW_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformscreen.cpp b/src/plugins/platforms/androidmini/qandroidplatformscreen.cpp
new file mode 100755
index 0000000..8521d76
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformscreen.cpp
@@ -0,0 +1,625 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QDebug>
+#include <QTime>
+
+#include <qpa/qwindowsysteminterface.h>
+#include <private/qcore_unix_p.h>
+
+#include "qandroidplatformscreen.h"
+#include "qandroidplatformbackingstore.h"
+#include "qlinuxfbintegration.h"
+#include "qandroidplatformwindow.h"
+#include "androiddeadlockprotector.h"
+
+#include <qguiapplication.h>
+
+#include <QtGui/QGuiApplication>
+#include <QtGui/QWindow>
+#include <QtGui/private/qwindow_p.h>
+#include <QtCore/QRegularExpression>
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <linux/kd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <limits.h>
+#include <signal.h>
+
+#include <linux/fb.h>
+
+QT_BEGIN_NAMESPACE
+
+static int openFramebufferDevice(const QString &dev)
+{
+    int fd = -1;
+
+    if (access(dev.toLatin1().constData(), R_OK|W_OK) == 0)
+        fd = QT_OPEN(dev.toLatin1().constData(), O_RDWR);
+
+    if (fd == -1) {
+        if (access(dev.toLatin1().constData(), R_OK) == 0)
+            fd = QT_OPEN(dev.toLatin1().constData(), O_RDONLY);
+    }
+
+    return fd;
+}
+
+static int determineDepth(const fb_var_screeninfo &vinfo)
+{
+    int depth = vinfo.bits_per_pixel;
+    if (depth== 24) {
+        depth = vinfo.red.length + vinfo.green.length + vinfo.blue.length;
+        if (depth <= 0)
+            depth = 24; // reset if color component lengths are not reported
+    } else if (depth == 16) {
+        depth = vinfo.red.length + vinfo.green.length + vinfo.blue.length;
+        if (depth <= 0)
+            depth = 16;
+    }
+    return depth;
+}
+
+static QRect determineGeometry(const fb_var_screeninfo &vinfo, const QRect &userGeometry)
+{
+    int xoff = vinfo.xoffset;
+    int yoff = vinfo.yoffset;
+    int w, h;
+    if (userGeometry.isValid()) {
+        w = userGeometry.width();
+        h = userGeometry.height();
+        if ((uint)w > vinfo.xres)
+            w = vinfo.xres;
+        if ((uint)h > vinfo.yres)
+            h = vinfo.yres;
+
+        int xxoff = userGeometry.x(), yyoff = userGeometry.y();
+        if (xxoff != 0 || yyoff != 0) {
+            if (xxoff < 0 || xxoff + w > (int)(vinfo.xres))
+                xxoff = vinfo.xres - w;
+            if (yyoff < 0 || yyoff + h > (int)(vinfo.yres))
+                yyoff = vinfo.yres - h;
+            xoff += xxoff;
+            yoff += yyoff;
+        } else {
+            xoff += (vinfo.xres - w)/2;
+            yoff += (vinfo.yres - h)/2;
+        }
+    } else {
+        w = vinfo.xres;
+        h = vinfo.yres;
+    }
+
+    if (w == 0 || h == 0) {
+        qWarning("Unable to find screen geometry, using 320x240");
+        w = 320;
+        h = 240;
+    }
+
+    return QRect(xoff, yoff, w, h);
+}
+
+static QSizeF determinePhysicalSize(const fb_var_screeninfo &vinfo, const QSize &mmSize, const QSize &res)
+{
+    int mmWidth = mmSize.width(), mmHeight = mmSize.height();
+
+    if (mmWidth <= 0 && mmHeight <= 0) {
+        if (vinfo.width != 0 && vinfo.height != 0
+            && vinfo.width != UINT_MAX && vinfo.height != UINT_MAX) {
+            mmWidth = vinfo.width;
+            mmHeight = vinfo.height;
+        } else {
+            const int dpi = 100;
+            mmWidth = qRound(res.width() * 25.4 / dpi);
+            mmHeight = qRound(res.height() * 25.4 / dpi);
+        }
+    } else if (mmWidth > 0 && mmHeight <= 0) {
+        mmHeight = res.height() * mmWidth/res.width();
+    } else if (mmHeight > 0 && mmWidth <= 0) {
+        mmWidth = res.width() * mmHeight/res.height();
+    }
+
+    return QSize(mmWidth, mmHeight);
+}
+
+static QImage::Format determineFormat(const fb_var_screeninfo &info, int depth)
+{
+    const fb_bitfield rgba[4] = { info.red, info.green,
+                                  info.blue, info.transp };
+
+    QImage::Format format = QImage::Format_Invalid;
+
+    switch (depth) {
+    case 32: {
+        const fb_bitfield argb8888[4] = {{16, 8, 0}, {8, 8, 0},
+                                         {0, 8, 0}, {24, 8, 0}};
+        const fb_bitfield abgr8888[4] = {{0, 8, 0}, {8, 8, 0},
+                                         {16, 8, 0}, {24, 8, 0}};
+        if (memcmp(rgba, argb8888, 4 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_ARGB32;
+        } else if (memcmp(rgba, argb8888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB32;
+        } else if (memcmp(rgba, abgr8888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB32;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+    case 24: {
+        const fb_bitfield rgb888[4] = {{16, 8, 0}, {8, 8, 0},
+                                       {0, 8, 0}, {0, 0, 0}};
+        const fb_bitfield bgr888[4] = {{0, 8, 0}, {8, 8, 0},
+                                       {16, 8, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB888;
+        } else if (memcmp(rgba, bgr888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB888;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+
+	case 18: {
+        const fb_bitfield rgb666[4] = {{12, 6, 0}, {6, 6, 0},
+                                       {0, 6, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb666, 3 * sizeof(fb_bitfield)) == 0)
+            format = QImage::Format_RGB666;
+        break;
+    }
+    case 16: {
+        const fb_bitfield rgb565[4] = {{11, 5, 0}, {5, 6, 0},
+                                       {0, 5, 0}, {0, 0, 0}};
+        const fb_bitfield bgr565[4] = {{0, 5, 0}, {5, 6, 0},
+                                       {11, 5, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb565, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB16;
+        } else if (memcmp(rgba, bgr565, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB16;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+    case 15: {
+        const fb_bitfield rgb1555[4] = {{10, 5, 0}, {5, 5, 0},
+                                        {0, 5, 0}, {15, 1, 0}};
+        const fb_bitfield bgr1555[4] = {{0, 5, 0}, {5, 5, 0},
+                                        {10, 5, 0}, {15, 1, 0}};
+        if (memcmp(rgba, rgb1555, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB555;
+        } else if (memcmp(rgba, bgr1555, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB555;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+    case 12: {
+        const fb_bitfield rgb444[4] = {{8, 4, 0}, {4, 4, 0},
+                                       {0, 4, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb444, 3 * sizeof(fb_bitfield)) == 0)
+            format = QImage::Format_RGB444;
+        break;
+    }
+    case 8:
+        break;
+    case 1:
+        format = QImage::Format_Mono; //###: LSB???
+        break;
+    default:
+        break;
+    }
+
+    return format;
+}
+
+
+static void blankScreen(int fd, bool on)
+{
+    ioctl(fd, FBIOBLANK, on ? VESA_POWERDOWN : VESA_NO_BLANKING);
+}
+
+bool QAndroidPlatformScreen::event(QEvent *event)
+{
+    if (event->type() == QEvent::UpdateRequest) {
+        doRedraw();
+        mUpdatePending = false;
+        return true;
+    }
+    return QObject::event(event);
+}
+
+void QAndroidPlatformScreen::initMainSurface()
+{
+	QRegularExpression ttyRx(QLatin1String("tty=(.*)"));
+    QRegularExpression fbRx(QLatin1String("fb=(.*)"));
+    QRegularExpression mmSizeRx(QLatin1String("mmsize=(\\d+)x(\\d+)"));
+    QRegularExpression sizeRx(QLatin1String("size=(\\d+)x(\\d+)"));
+    QRegularExpression offsetRx(QLatin1String("offset=(\\d+)x(\\d+)"));
+
+    QString fbDevice, ttyDevice;
+    QSize userMmSize;
+    QRect userGeometry;
+    bool doSwitchToGraphicsMode = true;
+
+    // Parse arguments
+    if (fbDevice.isEmpty()) {
+        fbDevice = QLatin1String("/dev/fb0");
+        if (!QFile::exists(fbDevice))
+            fbDevice = QLatin1String("/dev/graphics/fb0");
+        if (!QFile::exists(fbDevice)) {
+            qWarning("Unable to figure out framebuffer device. Specify it manually.");
+            return ;
+        }
+    }
+
+    // Open the device
+    mFbFd = openFramebufferDevice(fbDevice);
+    if (mFbFd == -1) {
+        qErrnoWarning(errno, "Failed to open framebuffer %s", qPrintable(fbDevice));
+        return ;
+    }
+
+    // Read the fixed and variable screen information
+    fb_fix_screeninfo finfo;
+    fb_var_screeninfo vinfo;
+    memset(&vinfo, 0, sizeof(vinfo));
+    memset(&finfo, 0, sizeof(finfo));
+
+    if (ioctl(mFbFd, FBIOGET_FSCREENINFO, &finfo) != 0) {
+        qErrnoWarning(errno, "Error reading fixed information");
+        return ;
+    }
+
+    if (ioctl(mFbFd, FBIOGET_VSCREENINFO, &vinfo)) {
+        qErrnoWarning(errno, "Error reading variable information");
+        return ;
+    }
+
+    m_depth = determineDepth(vinfo);
+    mBytesPerLine = finfo.line_length;
+    QRect geometry = determineGeometry(vinfo, userGeometry);
+    m_availableGeometry = QRect(QPoint(0, 0), geometry.size());
+    m_format = determineFormat(vinfo, m_depth);
+    m_physicalSize = determinePhysicalSize(vinfo, userMmSize, geometry.size());
+	m_size = QSize(geometry.width(), geometry.height());
+
+    // mmap the framebuffer
+    mMmap.size = finfo.smem_len;
+    uchar *data = (unsigned char *)mmap(0, mMmap.size, PROT_READ | PROT_WRITE, MAP_SHARED, mFbFd, 0);
+    if ((long)data == -1) {
+        qErrnoWarning(errno, "Failed to mmap framebuffer");
+        return ;
+    }
+
+    mMmap.offset = geometry.y() * mBytesPerLine + geometry.x() * m_depth / 8;
+    mMmap.data = data + mMmap.offset;
+
+	mFbScreenImage = QImage(mMmap.data, geometry.width(), geometry.height(), mBytesPerLine, m_format);
+
+    blankScreen(mFbFd, false);
+
+}
+QAndroidPlatformScreen::QAndroidPlatformScreen()
+{
+	mMmap.data = 0;
+	mFbFd = -1;
+	mBlitter = nullptr;
+
+	initMainSurface();
+		
+	mUpdatePending = false;
+	scheduleUpdate();
+    //m_redrawTimer.setSingleShot(true);  //运行一次
+    //m_redrawTimer.setInterval(0);
+    //connect(&m_redrawTimer, SIGNAL(timeout()), this, SLOT(doRedraw()));
+}
+
+QAndroidPlatformScreen::~QAndroidPlatformScreen()
+{
+	if (mFbFd != -1) {
+        if (mMmap.data)
+            munmap(mMmap.data - mMmap.offset, mMmap.size);
+        close(mFbFd);
+    }
+
+    delete mBlitter;
+}
+
+QWindow *QAndroidPlatformScreen::topWindow() const
+{
+    for (QAndroidPlatformWindow *w : m_windowStack) {
+        if (w->window()->type() == Qt::Window ||
+                w->window()->type() == Qt::Popup ||
+                w->window()->type() == Qt::Dialog) {
+            return w->window();
+        }
+    }
+    return 0;
+}
+
+QWindow *QAndroidPlatformScreen::topLevelAt(const QPoint &p) const
+{
+    for (QAndroidPlatformWindow *w : m_windowStack) {
+        if (w->geometry().contains(p, false) && w->window()->isVisible())
+            return w->window();
+    }
+    return 0;
+}
+
+void QAndroidPlatformScreen::addWindow(QAndroidPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+    Q_ASSERT(!m_windowStack.contains(window));
+    m_windowStack.prepend(window);
+    if (window->isRaster()) {
+        m_rasterSurfaces.ref();
+        setDirty(window->geometry());
+    }
+
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+
+void QAndroidPlatformScreen::removeWindow(QAndroidPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+
+    Q_ASSERT(m_windowStack.contains(window));
+    m_windowStack.removeOne(window);
+    Q_ASSERT(!m_windowStack.contains(window));
+
+    if (window->isRaster()) {
+        m_rasterSurfaces.deref();
+        setDirty(window->geometry());
+    }
+
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+
+void QAndroidPlatformScreen::raise(QAndroidPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+    int index = m_windowStack.indexOf(window);
+    if (index <= 0)
+        return;
+    m_windowStack.move(index, 0);
+    if (window->isRaster()) {
+        setDirty(window->geometry());
+    }
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+
+void QAndroidPlatformScreen::lower(QAndroidPlatformWindow *window)
+{
+    if (window->parent() && window->isRaster())
+        return;
+
+    int index = m_windowStack.indexOf(window);
+    if (index == -1 || index == (m_windowStack.size() - 1))
+        return;
+    m_windowStack.move(index, m_windowStack.size() - 1);
+    if (window->isRaster()) {
+        setDirty(window->geometry());
+    }
+    QWindow *w = topWindow();
+    QWindowSystemInterface::handleWindowActivated(w);
+    topWindowChanged(w);
+}
+
+void QAndroidPlatformScreen::scheduleUpdate()
+{
+//modify by chapin
+    /*if (!m_redrawTimer.isActive())
+	{
+        m_redrawTimer.start();
+	}*/
+	if (!mUpdatePending) {
+        mUpdatePending = true;
+        QCoreApplication::postEvent(this, new QEvent(QEvent::UpdateRequest));
+    }
+}
+
+void QAndroidPlatformScreen::setDirty(const QRect &rect)
+{
+    QRect intersection = rect.intersected(m_availableGeometry);
+    m_dirtyRect |= intersection;
+    scheduleUpdate();
+}
+
+void QAndroidPlatformScreen::setPhysicalSize(const QSize &size)
+{
+    m_physicalSize = size;
+}
+
+void QAndroidPlatformScreen::setSize(const QSize &size)
+{
+    m_size = size;
+    QWindowSystemInterface::handleScreenGeometryChange(QPlatformScreen::screen(), geometry(), availableGeometry());
+}
+
+void QAndroidPlatformScreen::setAvailableGeometry(const QRect &rect)
+{
+    if (m_availableGeometry == rect)
+        return;
+
+    QRect oldGeometry = m_availableGeometry;
+
+    m_availableGeometry = rect;
+    QWindowSystemInterface::handleScreenGeometryChange(QPlatformScreen::screen(), geometry(), availableGeometry());
+    resizeMaximizedWindows();
+
+    if (oldGeometry.width() == 0 && oldGeometry.height() == 0 && rect.width() > 0 && rect.height() > 0) {
+        QList<QWindow *> windows = QGuiApplication::allWindows();
+        for (int i = 0; i < windows.size(); ++i) {
+            QWindow *w = windows.at(i);
+            if (w->handle()) {
+                QRect geometry = w->handle()->geometry();
+                if (geometry.width() > 0 && geometry.height() > 0)
+                    QWindowSystemInterface::handleExposeEvent(w, QRect(QPoint(0, 0), geometry.size()));
+            }
+        }
+    }
+}
+
+void QAndroidPlatformScreen::topWindowChanged(QWindow *w)
+{
+    if (w != 0) {
+        QAndroidPlatformWindow *platformWindow = static_cast<QAndroidPlatformWindow *>(w->handle());
+        if (platformWindow != 0)
+            platformWindow->updateStatusBarVisibility();
+    }
+}
+
+int QAndroidPlatformScreen::rasterSurfaces()
+{
+    return m_rasterSurfaces;
+}
+
+void QAndroidPlatformScreen::doRedraw()
+{
+
+    if (m_dirtyRect.isEmpty())
+        return;
+
+    // Stop if there are no visible raster windows. If we only have RasterGLSurface
+    // windows that have renderToTexture children (i.e. they need the OpenGL path) then
+    // we do not need an overlay surface.
+//modify by chapin
+    /*bool hasVisibleRasterWindows = false;
+    for (QAndroidPlatformWindow *window : qAsConst(m_windowStack)) {
+        if (window->window()->isVisible() && window->isRaster() && !qt_window_private(window->window())->compositing) {
+            hasVisibleRasterWindows = true;
+            break;
+        }
+    }
+    if (!hasVisibleRasterWindows) {
+        return;
+    }*/
+
+    int bpp = 4;
+
+	if (!mBlitter)
+        mBlitter = new QPainter(&mFbScreenImage);
+    mBlitter->setCompositionMode(QPainter::CompositionMode_Source);
+
+    QRegion visibleRegion(m_dirtyRect);
+	
+    for (QAndroidPlatformWindow *window : qAsConst(m_windowStack)) {
+        if (!window->window()->isVisible()) //modify by chapin for exit app
+                //|| qt_window_private(window->window())->compositing
+                //|| !window->isRaster())
+            continue;
+
+        const QVector<QRect> visibleRects = visibleRegion.rects();
+        for (const QRect &rect : visibleRects) {
+            QRect targetRect = window->geometry();
+            targetRect &= rect;
+
+            if (targetRect.isNull())
+                continue;
+
+            visibleRegion -= targetRect;
+            QRect windowRect = targetRect.translated(-window->geometry().topLeft());
+            QAndroidPlatformBackingStore *backingStore = static_cast<QAndroidPlatformWindow *>(window)->backingStore();
+            if (backingStore)
+			{
+
+                mBlitter->drawImage(targetRect.topLeft(), backingStore->toImage(), windowRect);
+			}
+        }
+    }
+
+    for (const QRect &rect : visibleRegion)
+        mBlitter->fillRect(rect, QColor(Qt::transparent));
+
+//default fresh ok
+    m_dirtyRect = QRect();
+}
+
+Qt::ScreenOrientation QAndroidPlatformScreen::orientation() const
+{
+    return QLinuxFbIntegration::m_orientation;
+}
+
+Qt::ScreenOrientation QAndroidPlatformScreen::nativeOrientation() const
+{
+    return QLinuxFbIntegration::m_nativeOrientation;
+}
+
+/*!
+    Reimplement this function in subclass to return the logical horizontal
+    and vertical dots per inch metrics of the screen.
+
+    The logical dots per inch metrics are used by QFont to convert point sizes
+    to pixel sizes.
+
+    The default implementation uses the screen pixel size and physical size to
+    compute the metrics.
+
+    \sa physicalSize
+*/
+QDpi QAndroidPlatformScreen::logicalDpi() const
+{
+    QSizeF ps = physicalSize();
+    QSize s = geometry().size();
+
+    return QDpi(25.4 * s.width() / ps.width(),   //modify by chapin for size of font
+                25.4 * s.height() / ps.height());
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformscreen.h b/src/plugins/platforms/androidmini/qandroidplatformscreen.h
new file mode 100755
index 0000000..b3cd618
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformscreen.h
@@ -0,0 +1,135 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMSCREEN_H
+#define QANDROIDPLATFORMSCREEN_H
+
+#include <qpa/qplatformscreen.h>
+#include <QList>
+#include <QPainter>
+#include <QTimer>
+#include <QWaitCondition>
+
+#ifndef USE_ANDROID_OPENGGL  //frameworks/native/include/binder/SafeInterface.h 中的宏控制
+#define USE_ANDROID_OPENGGL
+#endif
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformWindow;
+class QPainter;
+
+
+class QAndroidPlatformScreen: public QObject, public QPlatformScreen
+{
+    Q_OBJECT
+public:
+    QAndroidPlatformScreen();
+    ~QAndroidPlatformScreen();
+
+    QRect geometry() const override { return QRect(QPoint(), m_size); }
+    QRect availableGeometry() const override { return m_availableGeometry; }
+    int depth() const override { return m_depth; }
+    QImage::Format format() const override { return m_format; }
+    QSizeF physicalSize() const override {qDebug("android platform physicalSize"); return m_physicalSize; }
+
+    inline QWindow *topWindow() const;
+    QWindow *topLevelAt(const QPoint & p) const override;
+    bool event(QEvent *event) Q_DECL_OVERRIDE;
+
+    // compositor api
+    void addWindow(QAndroidPlatformWindow *window);
+    void removeWindow(QAndroidPlatformWindow *window);
+    void raise(QAndroidPlatformWindow *window);
+    void lower(QAndroidPlatformWindow *window);
+
+	void initMainSurface();
+    void scheduleUpdate();
+    void topWindowChanged(QWindow *w);
+    int rasterSurfaces();
+
+public slots:
+    void setDirty(const QRect &rect);
+    void setPhysicalSize(const QSize &size);
+    void setAvailableGeometry(const QRect &rect);
+    void setSize(const QSize &size);
+
+protected:
+	typedef QList<QAndroidPlatformWindow *> WindowStackType;
+	WindowStackType m_windowStack;
+
+    QRect m_dirtyRect;
+    QTimer m_redrawTimer;
+	bool mUpdatePending;
+
+    QRect m_availableGeometry;
+    int m_depth;
+    QImage::Format m_format;
+    QSizeF m_physicalSize;
+	int mFbFd;
+    int mTtyFd;
+
+    QImage mFbScreenImage;
+    int mBytesPerLine;
+    int mOldTtyMode;
+
+    struct {
+        uchar *data;
+        int offset, size;
+    } mMmap;
+
+	QPainter *mBlitter;
+private:
+    Qt::ScreenOrientation orientation() const override;
+    Qt::ScreenOrientation nativeOrientation() const override;
+
+private slots:
+    void doRedraw();
+	QDpi logicalDpi() const override;
+
+private:
+    QAtomicInt m_rasterSurfaces = 0;
+
+    QWaitCondition m_surfaceWaitCondition;
+    QSize m_size;
+};
+
+QT_END_NAMESPACE
+#endif
diff --git a/src/plugins/platforms/androidmini/qandroidplatformservices.cpp b/src/plugins/platforms/androidmini/qandroidplatformservices.cpp
new file mode 100755
index 0000000..1366378
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformservices.cpp
@@ -0,0 +1,86 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidplatformservices.h"
+#include <QUrl>
+#include <QFile>
+#include <QDebug>
+#include <QMimeDatabase>
+#include <QtCore/private/qjni_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformServices::QAndroidPlatformServices()
+{
+}
+
+bool QAndroidPlatformServices::openUrl(const QUrl &theUrl)
+{
+    QString mime;
+    QUrl url(theUrl);
+
+    // if the file is local, we need to pass the MIME type, otherwise Android
+    // does not start an Intent to view this file
+    if ((url.scheme().isEmpty() && QFile::exists(url.path())) || url.isLocalFile()) {
+        // a real URL including the scheme is needed, else the Intent can not be started
+        url.setScheme(QLatin1String("file"));
+
+        QMimeDatabase mimeDb;
+        mime = mimeDb.mimeTypeForUrl(url).name();
+    }
+
+    QJNIObjectPrivate urlString = QJNIObjectPrivate::fromString(url.toString());
+    QJNIObjectPrivate mimeString = QJNIObjectPrivate::fromString(mime);
+    return QJNIObjectPrivate::callStaticMethod<jboolean>(QtAndroid::applicationClass(),
+                                                         "openURL",
+                                                         "(Ljava/lang/String;Ljava/lang/String;)Z",
+                                                         urlString.object(), mimeString.object());
+}
+
+bool QAndroidPlatformServices::openDocument(const QUrl &url)
+{
+    return openUrl(url);
+}
+
+QByteArray QAndroidPlatformServices::desktopEnvironment() const
+{
+    return QByteArray("Android");
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformservices.h b/src/plugins/platforms/androidmini/qandroidplatformservices.h
new file mode 100755
index 0000000..6f2f0a3
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformservices.h
@@ -0,0 +1,59 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef ANDROIDPLATFORMDESKTOPSERVICE_H
+#define ANDROIDPLATFORMDESKTOPSERVICE_H
+
+#include <qpa/qplatformservices.h>
+#include "androidjnimain.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidPlatformServices: public QPlatformServices
+{
+public:
+    QAndroidPlatformServices();
+    bool openUrl(const QUrl &url) override;
+    bool openDocument(const QUrl &url) override;
+    QByteArray desktopEnvironment() const override;
+};
+
+QT_END_NAMESPACE
+
+#endif // ANDROIDPLATFORMDESKTOPSERVICE_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformsurface.cpp b/src/plugins/platforms/androidmini/qandroidplatformsurface.cpp
new file mode 100755
index 0000000..a818ddb
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformsurface.cpp
@@ -0,0 +1,52 @@
+#ifndef QANDROIDPLATFORMSURFACE_CPP
+#define QANDROIDPLATFORMSURFACE_CPP
+#include "qandroidplatformsurface.h"
+
+using namespace android;
+#define MAIN_SURFACE_WIDTH 720
+#define MAIN_SURFACE_HEIGHT 1280
+
+sp< SurfaceControl > QAndroidPlatformSurface::mainSurfaceControl;
+sp< SurfaceControl > QAndroidPlatformSurface::getSurfaceControl(int type) 
+{
+	int ret;
+	if (type == MAIN_SURFACE)  //main surface
+	{
+		if ( mainSurfaceControl != nullptr)
+			return mainSurfaceControl;
+
+		sp < SurfaceComposerClient > mComposerClient = new SurfaceComposerClient;
+		if (mComposerClient == NULL)
+		{		
+			qWarning("composer client is null");
+			return nullptr;
+		}
+		
+		ret = mComposerClient->initCheck();
+		if (ret != 0)
+			qWarning("init check fail");
+
+		sp < IBinder > dtoken(SurfaceComposerClient::getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
+
+		mainSurfaceControl = mComposerClient->createSurface(
+                    String8("main surface"),
+                    MAIN_SURFACE_WIDTH, MAIN_SURFACE_HEIGHT,
+                    PIXEL_FORMAT_RGBA_8888, 0);
+
+		SurfaceComposerClient::openGlobalTransaction();
+    	mainSurfaceControl->setLayer(0x70000000);
+    	mainSurfaceControl->show();
+    	SurfaceComposerClient::closeGlobalTransaction();
+	}		
+	
+	return mainSurfaceControl;
+}
+
+QAndroidPlatformSurface::QAndroidPlatformSurface()
+{
+}
+
+QAndroidPlatformSurface::~QAndroidPlatformSurface()
+{
+}
+#endif
diff --git a/src/plugins/platforms/androidmini/qandroidplatformsurface.h b/src/plugins/platforms/androidmini/qandroidplatformsurface.h
new file mode 100755
index 0000000..44cf2db
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformsurface.h
@@ -0,0 +1,36 @@
+#ifndef QANDROIDPLATFORMSURFACE_H
+#define QANDROIDPLATFORMSURFACE_H
+
+#ifndef USE_ANDROID_OPENGGL  //frameworks/native/include/binder/SafeInterface.h 中的宏控制
+#define USE_ANDROID_OPENGGL
+#endif
+
+#include "common.h"
+#include <QtGui/qtguiglobal.h>
+#include <QObject>
+#include <gui/ISurfaceComposer.h>
+#include <gui/Surface.h>
+#include <gui/SurfaceComposerClient.h>
+
+#include "androidsurfaceclient.h"
+#include <android/native_window.h>
+
+QT_BEGIN_NAMESPACE
+using namespace android;
+
+class QAndroidPlatformSurface;
+
+class QAndroidPlatformSurface: public QObject
+{
+    Q_OBJECT
+public:
+    QAndroidPlatformSurface();
+    ~QAndroidPlatformSurface();
+	static sp< SurfaceControl > getSurfaceControl(int type);
+
+private:
+	static sp< SurfaceControl > mainSurfaceControl;
+};
+
+QT_END_NAMESPACE
+#endif
diff --git a/src/plugins/platforms/androidmini/qandroidplatformtheme.h b/src/plugins/platforms/androidmini/qandroidplatformtheme.h
new file mode 100755
index 0000000..b49d251
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformtheme.h
@@ -0,0 +1,88 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 BogDan Vatra <bogdan@kde.org>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDPLATFORMTHEME_H
+#define QANDROIDPLATFORMTHEME_H
+
+#include <qpa/qplatformtheme.h>
+#include <QtGui/qfont.h>
+#include <QtGui/qpalette.h>
+
+#include <QJsonObject>
+
+#include <memory>
+
+QT_BEGIN_NAMESPACE
+
+struct AndroidStyle
+{
+    static QJsonObject loadStyleData();
+    QJsonObject m_styleData;
+    QPalette m_standardPalette;
+    QHash<int, QPalette> m_palettes;
+    QHash<int, QFont> m_fonts;
+    QHash<QByteArray, QFont> m_QWidgetsFonts;
+};
+
+class QAndroidPlatformNativeInterface;
+class QAndroidPlatformTheme: public QPlatformTheme
+{
+public:
+    QAndroidPlatformTheme(QAndroidPlatformNativeInterface * androidPlatformNativeInterface);
+    QPlatformMenuBar *createPlatformMenuBar() const override;
+    QPlatformMenu *createPlatformMenu() const override;
+    QPlatformMenuItem *createPlatformMenuItem() const override;
+    void showPlatformMenuBar() override;
+    const QPalette *palette(Palette type = SystemPalette) const override;
+    const QFont *font(Font type = SystemFont) const override;
+    QVariant themeHint(ThemeHint hint) const override;
+    QString standardButtonText(int button) const override;
+    bool usePlatformNativeDialog(DialogType type) const override;
+    QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const override;
+
+
+private:
+    std::shared_ptr<AndroidStyle> m_androidStyleData;
+    QPalette m_defaultPalette;
+    QFont m_systemFont;
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMTHEME_H
diff --git a/src/plugins/platforms/androidmini/qandroidplatformwindow.cpp b/src/plugins/platforms/androidmini/qandroidplatformwindow.cpp
new file mode 100755
index 0000000..45c7f93
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformwindow.cpp
@@ -0,0 +1,179 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidplatformwindow.h"
+#include "qandroidplatformopenglcontext.h"
+#include "qandroidplatformscreen.h"
+
+#include <qguiapplication.h>
+#include <qpa/qwindowsysteminterface.h>
+
+QT_BEGIN_NAMESPACE
+
+QAndroidPlatformWindow::QAndroidPlatformWindow(QWindow *window)
+    : QPlatformWindow(window)
+{
+    m_windowFlags = Qt::Widget;
+    m_windowState = Qt::WindowNoState;
+    static QAtomicInt winIdGenerator(1);
+    m_windowId = winIdGenerator.fetchAndAddRelaxed(1);
+    setWindowState(window->windowState());
+}
+
+void QAndroidPlatformWindow::lower()
+{
+//modified by chapin
+    platformScreen()->lower(this);
+}
+
+void QAndroidPlatformWindow::raise()
+{
+//modified by chapin
+    updateStatusBarVisibility();
+    platformScreen()->raise(this);
+}
+
+void QAndroidPlatformWindow::setGeometry(const QRect &rect)
+{
+    QWindowSystemInterface::handleGeometryChange(window(), rect);
+    QPlatformWindow::setGeometry(rect);
+}
+
+void QAndroidPlatformWindow::setVisible(bool visible)
+{
+    if (visible)
+        updateStatusBarVisibility();
+
+//modify by chapin
+    if (visible) {
+        if (m_windowState & Qt::WindowFullScreen)
+		{
+            setGeometry(platformScreen()->geometry());
+		}
+        else if (m_windowState & Qt::WindowMaximized)
+		{
+            setGeometry(platformScreen()->availableGeometry());
+		}
+    }
+
+    if (visible)
+	{
+        platformScreen()->addWindow(this);
+	}
+    else
+	{
+        platformScreen()->removeWindow(this);
+	}
+
+    QRect availableGeometry = screen()->availableGeometry();
+    if (geometry().width() > 0 && geometry().height() > 0 && availableGeometry.width() > 0 && availableGeometry.height() > 0)
+        QPlatformWindow::setVisible(visible);
+}
+
+void QAndroidPlatformWindow::setWindowState(Qt::WindowState state)
+{
+    if (m_windowState == state)
+        return;
+
+    QPlatformWindow::setWindowState(state);
+    m_windowState = state;
+
+    if (window()->isVisible())
+        updateStatusBarVisibility();
+}
+
+void QAndroidPlatformWindow::setWindowFlags(Qt::WindowFlags flags)
+{
+    if (m_windowFlags == flags)
+        return;
+
+    m_windowFlags = flags;
+}
+
+Qt::WindowFlags QAndroidPlatformWindow::windowFlags() const
+{
+    return m_windowFlags;
+}
+
+void QAndroidPlatformWindow::setParent(const QPlatformWindow *window)
+{
+    Q_UNUSED(window);
+}
+
+QAndroidPlatformScreen *QAndroidPlatformWindow::platformScreen() const
+{
+    return static_cast<QAndroidPlatformScreen *>(window()->screen()->handle());
+}
+
+void QAndroidPlatformWindow::propagateSizeHints()
+{
+    //shut up warning from default implementation
+}
+
+void QAndroidPlatformWindow::requestActivateWindow()
+{
+//modified by chapin
+    platformScreen()->topWindowChanged(window());
+}
+
+void QAndroidPlatformWindow::updateStatusBarVisibility()
+{
+    Qt::WindowFlags flags = window()->flags();
+    bool isNonRegularWindow = flags & (Qt::Popup | Qt::Dialog | Qt::Sheet) & ~Qt::Window;
+}
+
+bool QAndroidPlatformWindow::isExposed() const
+{
+    return qApp->applicationState() > Qt::ApplicationHidden
+            && window()->isVisible()
+            && !window()->geometry().isEmpty();
+}
+
+void QAndroidPlatformWindow::applicationStateChanged(Qt::ApplicationState)
+{
+    QRegion region;
+    if (isExposed())
+        region = QRect(QPoint(), geometry().size());
+
+    QWindowSystemInterface::handleExposeEvent(window(), region);
+    QWindowSystemInterface::flushWindowSystemEvents();
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidplatformwindow.h b/src/plugins/platforms/androidmini/qandroidplatformwindow.h
new file mode 100755
index 0000000..0393b04
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidplatformwindow.h
@@ -0,0 +1,110 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef ANDROIDPLATFORMWINDOW_H
+#define ANDROIDPLATFORMWINDOW_H
+#include <qobject.h>
+#include <qrect.h>
+#include <qpa/qplatformwindow.h>
+
+QT_BEGIN_NAMESPACE
+
+#ifdef USE_LINUXFB
+class QLinuxFbScreen;
+#else
+class QAndroidPlatformScreen;
+#endif
+class QAndroidPlatformBackingStore;
+
+class QAndroidPlatformWindow: public QPlatformWindow
+{
+public:
+    explicit QAndroidPlatformWindow(QWindow *window);
+
+    void lower() override;
+    void raise() override;
+
+    void setVisible(bool visible) override;
+
+    void setWindowState(Qt::WindowState state) override;
+    void setWindowFlags(Qt::WindowFlags flags) override;
+    Qt::WindowFlags windowFlags() const;
+    void setParent(const QPlatformWindow *window) override;
+    WId winId() const override { return m_windowId; }
+
+#ifdef USE_LINUXFB
+    QLinuxFbScreen *platformScreen() const;
+#else
+    QAndroidPlatformScreen *platformScreen() const;
+#endif
+
+    void propagateSizeHints() override;
+    void requestActivateWindow() override;
+    void updateStatusBarVisibility();
+    inline bool isRaster() const {
+        if (isForeignWindow())
+            return false;
+
+        return window()->surfaceType() == QSurface::RasterSurface
+            || window()->surfaceType() == QSurface::RasterGLSurface;
+    }
+    bool isExposed() const override;
+
+    virtual void applicationStateChanged(Qt::ApplicationState);
+
+    void setBackingStore(QAndroidPlatformBackingStore *store) { m_backingStore = store; }
+    QAndroidPlatformBackingStore *backingStore() const { return m_backingStore; }
+
+    virtual void repaint(const QRegion &) { }
+
+protected:
+    void setGeometry(const QRect &rect) override;
+
+protected:
+    Qt::WindowFlags m_windowFlags;
+    Qt::WindowState m_windowState;
+
+    WId m_windowId;
+
+    QAndroidPlatformBackingStore *m_backingStore = nullptr;
+};
+
+QT_END_NAMESPACE
+#endif // ANDROIDPLATFORMWINDOW_H
diff --git a/src/plugins/platforms/androidmini/qandroidsystemlocale.cpp b/src/plugins/platforms/androidmini/qandroidsystemlocale.cpp
new file mode 100755
index 0000000..7fe36aa
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidsystemlocale.cpp
@@ -0,0 +1,177 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qandroidsystemlocale.h"
+#include "androidjnimain.h"
+#include <QtCore/private/qjni_p.h>
+#include "qdatetime.h"
+#include "qstringlist.h"
+#include "qvariant.h"
+
+QT_BEGIN_NAMESPACE
+
+QAndroidSystemLocale::QAndroidSystemLocale() : m_locale(QLocale::C)
+{
+}
+
+void QAndroidSystemLocale::getLocaleFromJava() const
+{
+    QWriteLocker locker(&m_lock);
+
+    QJNIObjectPrivate javaLocaleObject;
+    QJNIObjectPrivate javaActivity(QtAndroid::activity());
+    if (!javaActivity.isValid())
+        javaActivity = QtAndroid::service();
+    if (javaActivity.isValid()) {
+        QJNIObjectPrivate resources = javaActivity.callObjectMethod("getResources", "()Landroid/content/res/Resources;");
+        QJNIObjectPrivate configuration = resources.callObjectMethod("getConfiguration", "()Landroid/content/res/Configuration;");
+
+        javaLocaleObject = configuration.getObjectField("locale", "Ljava/util/Locale;");
+    } else {
+        javaLocaleObject = QJNIObjectPrivate::callStaticObjectMethod("java/util/Locale", "getDefault", "()Ljava/util/Locale;");
+    }
+
+    QString languageCode = javaLocaleObject.callObjectMethod("getLanguage", "()Ljava/lang/String;").toString();
+    QString countryCode = javaLocaleObject.callObjectMethod("getCountry", "()Ljava/lang/String;").toString();
+
+    m_locale = QLocale(languageCode + QLatin1Char('_') + countryCode);
+}
+
+QVariant QAndroidSystemLocale::query(QueryType type, QVariant in) const
+{
+    if (type == LocaleChanged) {
+        getLocaleFromJava();
+        return QVariant();
+    }
+
+    QReadLocker locker(&m_lock);
+
+    switch (type) {
+    case DecimalPoint:
+        return m_locale.decimalPoint();
+    case GroupSeparator:
+        return m_locale.groupSeparator();
+    case ZeroDigit:
+        return m_locale.zeroDigit();
+    case NegativeSign:
+        return m_locale.negativeSign();
+    case DateFormatLong:
+        return m_locale.dateFormat(QLocale::LongFormat);
+    case DateFormatShort:
+        return m_locale.dateFormat(QLocale::ShortFormat);
+    case TimeFormatLong:
+        return m_locale.timeFormat(QLocale::LongFormat);
+    case TimeFormatShort:
+        return m_locale.timeFormat(QLocale::ShortFormat);
+    case DayNameLong:
+        return m_locale.dayName(in.toInt(), QLocale::LongFormat);
+    case DayNameShort:
+        return m_locale.dayName(in.toInt(), QLocale::ShortFormat);
+    case MonthNameLong:
+        return m_locale.monthName(in.toInt(), QLocale::LongFormat);
+    case MonthNameShort:
+        return m_locale.monthName(in.toInt(), QLocale::ShortFormat);
+    case StandaloneMonthNameLong:
+        return m_locale.standaloneMonthName(in.toInt(), QLocale::LongFormat);
+    case StandaloneMonthNameShort:
+        return m_locale.standaloneMonthName(in.toInt(), QLocale::ShortFormat);
+    case DateToStringLong:
+        return m_locale.toString(in.toDate(), QLocale::LongFormat);
+    case DateToStringShort:
+        return m_locale.toString(in.toDate(), QLocale::ShortFormat);
+    case TimeToStringLong:
+        return m_locale.toString(in.toTime(), QLocale::LongFormat);
+    case TimeToStringShort:
+        return m_locale.toString(in.toTime(), QLocale::ShortFormat);
+    case DateTimeFormatLong:
+        return m_locale.dateTimeFormat(QLocale::LongFormat);
+    case DateTimeFormatShort:
+        return m_locale.dateTimeFormat(QLocale::ShortFormat);
+    case DateTimeToStringLong:
+        return m_locale.toString(in.toDateTime(), QLocale::LongFormat);
+    case DateTimeToStringShort:
+        return m_locale.toString(in.toDateTime(), QLocale::ShortFormat);
+    case PositiveSign:
+        return m_locale.positiveSign();
+    case AMText:
+        return m_locale.amText();
+    case PMText:
+        return m_locale.pmText();
+    case FirstDayOfWeek:
+        return m_locale.firstDayOfWeek();
+    case CurrencySymbol:
+        return m_locale .currencySymbol(QLocale::CurrencySymbolFormat(in.toUInt()));
+    case CurrencyToString: {
+        switch (in.type()) {
+        case QVariant::Int:
+            return m_locale .toCurrencyString(in.toInt());
+        case QVariant::UInt:
+            return m_locale .toCurrencyString(in.toUInt());
+        case QVariant::Double:
+            return m_locale .toCurrencyString(in.toDouble());
+        case QVariant::LongLong:
+            return m_locale .toCurrencyString(in.toLongLong());
+        case QVariant::ULongLong:
+            return m_locale .toCurrencyString(in.toULongLong());
+        default:
+            break;
+        }
+        return QString();
+    }
+    case StringToStandardQuotation:
+        return m_locale.quoteString(in.value<QStringRef>());
+    case StringToAlternateQuotation:
+        return m_locale.quoteString(in.value<QStringRef>(), QLocale::AlternateQuotation);
+    case ListToSeparatedString:
+        return m_locale.createSeparatedList(in.value<QStringList>());
+    case LocaleChanged:
+        Q_ASSERT_X(false, Q_FUNC_INFO, "This can't happen.");
+    default:
+        break;
+    }
+    return QVariant();
+}
+
+QLocale QAndroidSystemLocale::fallbackUiLocale() const
+{
+    QReadLocker locker(&m_lock);
+    return m_locale;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qandroidsystemlocale.h b/src/plugins/platforms/androidmini/qandroidsystemlocale.h
new file mode 100755
index 0000000..bc96d2e
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qandroidsystemlocale.h
@@ -0,0 +1,65 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QANDROIDSYSTEMLOCALE_H
+#define QANDROIDSYSTEMLOCALE_H
+
+#include "private/qlocale_p.h"
+#include <QtCore/qreadwritelock.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAndroidSystemLocale : public QSystemLocale
+{
+public:
+    QAndroidSystemLocale();
+
+    QVariant query(QueryType type, QVariant in) const override;
+    QLocale fallbackUiLocale() const override;
+
+private:
+    void getLocaleFromJava() const;
+
+    mutable QLocale m_locale;
+    mutable QReadWriteLock m_lock;
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDSYSTEMLOCALE_H
diff --git a/src/plugins/platforms/androidmini/qlinuxfbdrmscreen.cpp b/src/plugins/platforms/androidmini/qlinuxfbdrmscreen.cpp
new file mode 100755
index 0000000..e15d6fe
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qlinuxfbdrmscreen.cpp
@@ -0,0 +1,412 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+// Experimental DRM dumb buffer backend.
+//
+// TODO:
+// Multiscreen: QWindow-QScreen(-output) association. Needs some reorg (device cannot be owned by screen)
+// Find card via devicediscovery like in eglfs_kms.
+// Mode restore like QEglFSKmsInterruptHandler.
+// Formats other then 32 bpp?
+// grabWindow
+
+#include "qlinuxfbdrmscreen.h"
+#include <QLoggingCategory>
+#include <QGuiApplication>
+#include <QPainter>
+#include <QtFbSupport/private/qfbcursor_p.h>
+#include <QtFbSupport/private/qfbwindow_p.h>
+#include <QtKmsSupport/private/qkmsdevice_p.h>
+#include <QtCore/private/qcore_unix_p.h>
+#include <sys/mman.h>
+
+QT_BEGIN_NAMESPACE
+
+Q_LOGGING_CATEGORY(qLcFbDrm, "qt.qpa.fb")
+
+static const int BUFFER_COUNT = 2;
+
+class QLinuxFbDevice : public QKmsDevice
+{
+public:
+    struct Framebuffer {
+        Framebuffer() : handle(0), pitch(0), size(0), fb(0), p(MAP_FAILED) { }
+        uint32_t handle;
+        uint32_t pitch;
+        uint64_t size;
+        uint32_t fb;
+        void *p;
+        QImage wrapper;
+    };
+
+    struct Output {
+        Output() : backFb(0), flipped(false) { }
+        QKmsOutput kmsOutput;
+        Framebuffer fb[BUFFER_COUNT];
+        QRegion dirty[BUFFER_COUNT];
+        int backFb;
+        bool flipped;
+        QSize currentRes() const {
+            const drmModeModeInfo &modeInfo(kmsOutput.modes[kmsOutput.mode]);
+            return QSize(modeInfo.hdisplay, modeInfo.vdisplay);
+        }
+    };
+
+    QLinuxFbDevice(QKmsScreenConfig *screenConfig);
+
+    bool open() override;
+    void close() override;
+
+    void createFramebuffers();
+    void destroyFramebuffers();
+    void setMode();
+
+    void swapBuffers(Output *output);
+
+    int outputCount() const { return m_outputs.count(); }
+    Output *output(int idx) { return &m_outputs[idx]; }
+
+private:
+    void *nativeDisplay() const override;
+    QPlatformScreen *createScreen(const QKmsOutput &output) override;
+    void registerScreen(QPlatformScreen *screen,
+                        bool isPrimary,
+                        const QPoint &virtualPos,
+                        const QList<QPlatformScreen *> &virtualSiblings) override;
+
+    bool createFramebuffer(Output *output, int bufferIdx);
+    void destroyFramebuffer(Output *output, int bufferIdx);
+
+    static void pageFlipHandler(int fd, unsigned int sequence,
+                                unsigned int tv_sec, unsigned int tv_usec, void *user_data);
+
+    QVector<Output> m_outputs;
+};
+
+QLinuxFbDevice::QLinuxFbDevice(QKmsScreenConfig *screenConfig)
+    : QKmsDevice(screenConfig, QStringLiteral("/dev/dri/card0"))
+{
+}
+
+bool QLinuxFbDevice::open()
+{
+    int fd = qt_safe_open(devicePath().toLocal8Bit().constData(), O_RDWR | O_CLOEXEC);
+    if (fd == -1) {
+        qErrnoWarning("Could not open DRM device %s", qPrintable(devicePath()));
+        return false;
+    }
+
+    uint64_t hasDumbBuf = 0;
+    if (drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &hasDumbBuf) == -1 || !hasDumbBuf) {
+        qWarning("Dumb buffers not supported");
+        qt_safe_close(fd);
+        return false;
+    }
+
+    setFd(fd);
+
+    qCDebug(qLcFbDrm, "DRM device %s opened", qPrintable(devicePath()));
+
+    return true;
+}
+
+void QLinuxFbDevice::close()
+{
+    for (Output &output : m_outputs)
+        output.kmsOutput.cleanup(this); // restore mode
+
+    m_outputs.clear();
+
+    if (fd() != -1) {
+        qCDebug(qLcFbDrm, "Closing DRM device");
+        qt_safe_close(fd());
+        setFd(-1);
+    }
+}
+
+void *QLinuxFbDevice::nativeDisplay() const
+{
+    Q_UNREACHABLE();
+    return nullptr;
+}
+
+QPlatformScreen *QLinuxFbDevice::createScreen(const QKmsOutput &output)
+{
+    qCDebug(qLcFbDrm, "Got a new output: %s", qPrintable(output.name));
+    Output o;
+    o.kmsOutput = output;
+    m_outputs.append(o);
+    return nullptr; // no platformscreen, we are not a platform plugin
+}
+
+void QLinuxFbDevice::registerScreen(QPlatformScreen *screen,
+                                    bool isPrimary,
+                                    const QPoint &virtualPos,
+                                    const QList<QPlatformScreen *> &virtualSiblings)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(isPrimary);
+    Q_UNUSED(virtualPos);
+    Q_UNUSED(virtualSiblings);
+    Q_UNREACHABLE();
+}
+
+bool QLinuxFbDevice::createFramebuffer(QLinuxFbDevice::Output *output, int bufferIdx)
+{
+    const QSize size = output->currentRes();
+    const uint32_t w = size.width();
+    const uint32_t h = size.height();
+    drm_mode_create_dumb creq = {
+        h,
+        w,
+        32,
+        0, 0, 0, 0
+    };
+    if (drmIoctl(fd(), DRM_IOCTL_MODE_CREATE_DUMB, &creq) == -1) {
+        qErrnoWarning(errno, "Failed to create dumb buffer");
+        return false;
+    }
+
+    Framebuffer &fb(output->fb[bufferIdx]);
+    fb.handle = creq.handle;
+    fb.pitch = creq.pitch;
+    fb.size = creq.size;
+    qCDebug(qLcFbDrm, "Got a dumb buffer for size %dx%d, handle %u, pitch %u, size %u",
+            w, h, fb.handle, fb.pitch, (uint) fb.size);
+
+    if (drmModeAddFB(fd(), w, h, 24, 32, fb.pitch, fb.handle, &fb.fb) == -1) {
+        qErrnoWarning(errno, "Failed to add FB");
+        return false;
+    }
+
+    drm_mode_map_dumb mreq = {
+        fb.handle,
+        0, 0
+    };
+    if (drmIoctl(fd(), DRM_IOCTL_MODE_MAP_DUMB, &mreq) == -1) {
+        qErrnoWarning(errno, "Failed to map dumb buffer");
+        return false;
+    }
+    fb.p = mmap(0, fb.size, PROT_READ | PROT_WRITE, MAP_SHARED, fd(), mreq.offset);
+    if (fb.p == MAP_FAILED) {
+        qErrnoWarning(errno, "Failed to mmap dumb buffer");
+        return false;
+    }
+
+    qCDebug(qLcFbDrm, "FB is %u, mapped at %p", fb.fb, fb.p);
+    memset(fb.p, 0, fb.size);
+
+    fb.wrapper = QImage(static_cast<uchar *>(fb.p), w, h, fb.pitch, QImage::Format_ARGB32);
+
+    return true;
+}
+
+void QLinuxFbDevice::createFramebuffers()
+{
+    for (Output &output : m_outputs) {
+        for (int i = 0; i < BUFFER_COUNT; ++i) {
+            if (!createFramebuffer(&output, i))
+                return;
+        }
+        output.backFb = 0;
+        output.flipped = false;
+    }
+}
+
+void QLinuxFbDevice::destroyFramebuffer(QLinuxFbDevice::Output *output, int bufferIdx)
+{
+    Framebuffer &fb(output->fb[bufferIdx]);
+    if (fb.p != MAP_FAILED)
+        munmap(fb.p, fb.size);
+    if (fb.fb) {
+        if (drmModeRmFB(fd(), fb.fb) == -1)
+            qErrnoWarning("Failed to remove fb");
+    }
+    if (fb.handle) {
+        drm_mode_destroy_dumb dreq = { fb.handle };
+        if (drmIoctl(fd(), DRM_IOCTL_MODE_DESTROY_DUMB, &dreq) == -1)
+            qErrnoWarning(errno, "Failed to destroy dumb buffer %u", fb.handle);
+    }
+    fb = Framebuffer();
+}
+
+void QLinuxFbDevice::destroyFramebuffers()
+{
+    for (Output &output : m_outputs) {
+        for (int i = 0; i < BUFFER_COUNT; ++i)
+            destroyFramebuffer(&output, i);
+    }
+}
+
+void QLinuxFbDevice::setMode()
+{
+    for (Output &output : m_outputs) {
+        drmModeModeInfo &modeInfo(output.kmsOutput.modes[output.kmsOutput.mode]);
+        if (drmModeSetCrtc(fd(), output.kmsOutput.crtc_id, output.fb[0].fb, 0, 0,
+                           &output.kmsOutput.connector_id, 1, &modeInfo) == -1) {
+            qErrnoWarning(errno, "Failed to set mode");
+            return;
+        }
+
+        output.kmsOutput.mode_set = true; // have cleanup() to restore the mode
+        output.kmsOutput.setPowerState(this, QPlatformScreen::PowerStateOn);
+    }
+}
+
+void QLinuxFbDevice::pageFlipHandler(int fd, unsigned int sequence,
+                                     unsigned int tv_sec, unsigned int tv_usec,
+                                     void *user_data)
+{
+    Q_UNUSED(fd);
+    Q_UNUSED(sequence);
+    Q_UNUSED(tv_sec);
+    Q_UNUSED(tv_usec);
+
+    Output *output = static_cast<Output *>(user_data);
+    output->backFb = (output->backFb + 1) % BUFFER_COUNT;
+}
+
+void QLinuxFbDevice::swapBuffers(Output *output)
+{
+    Framebuffer &fb(output->fb[output->backFb]);
+    if (drmModePageFlip(fd(), output->kmsOutput.crtc_id, fb.fb, DRM_MODE_PAGE_FLIP_EVENT, output) == -1) {
+        qErrnoWarning(errno, "Page flip failed");
+        return;
+    }
+
+    const int fbIdx = output->backFb;
+    while (output->backFb == fbIdx) {
+        drmEventContext drmEvent;
+        memset(&drmEvent, 0, sizeof(drmEvent));
+        drmEvent.version = 2;
+        drmEvent.vblank_handler = nullptr;
+        drmEvent.page_flip_handler = pageFlipHandler;
+        // Blocks until there is something to read on the drm fd
+        // and calls back pageFlipHandler once the flip completes.
+        drmHandleEvent(fd(), &drmEvent);
+    }
+}
+
+QLinuxFbDrmScreen::QLinuxFbDrmScreen(const QStringList &args)
+    : m_screenConfig(nullptr),
+      m_device(nullptr)
+{
+    Q_UNUSED(args);
+}
+
+QLinuxFbDrmScreen::~QLinuxFbDrmScreen()
+{
+    if (m_device) {
+        m_device->destroyFramebuffers();
+        m_device->close();
+        delete m_device;
+    }
+    delete m_screenConfig;
+}
+
+bool QLinuxFbDrmScreen::initialize()
+{
+    m_screenConfig = new QKmsScreenConfig;
+    m_device = new QLinuxFbDevice(m_screenConfig);
+    if (!m_device->open())
+        return false;
+
+    // Discover outputs. Calls back Device::createScreen().
+    m_device->createScreens();
+    // Now off to dumb buffer specifics.
+    m_device->createFramebuffers();
+    // Do the modesetting.
+    m_device->setMode();
+
+    QLinuxFbDevice::Output *output(m_device->output(0));
+
+    mGeometry = QRect(QPoint(0, 0), output->currentRes());
+    mDepth = 32;
+    mFormat = QImage::Format_ARGB32;
+    mPhysicalSize = output->kmsOutput.physical_size;
+    qCDebug(qLcFbDrm) << mGeometry << mPhysicalSize;
+
+    QFbScreen::initializeCompositor();
+
+    mCursor = new QFbCursor(this);
+
+    return true;
+}
+
+QRegion QLinuxFbDrmScreen::doRedraw()
+{
+    const QRegion dirty = QFbScreen::doRedraw();
+    if (dirty.isEmpty())
+        return dirty;
+
+    QLinuxFbDevice::Output *output(m_device->output(0));
+
+    for (int i = 0; i < BUFFER_COUNT; ++i)
+        output->dirty[i] += dirty;
+
+    if (output->fb[output->backFb].wrapper.isNull())
+        return dirty;
+
+    QPainter pntr(&output->fb[output->backFb].wrapper);
+    // Image has alpha but no need for blending at this stage.
+    // Do not waste time with the default SourceOver.
+    pntr.setCompositionMode(QPainter::CompositionMode_Source);
+    for (const QRect &rect : qAsConst(output->dirty[output->backFb]))
+        pntr.drawImage(rect, mScreenImage, rect);
+    pntr.end();
+
+    output->dirty[output->backFb] = QRegion();
+
+    m_device->swapBuffers(output);
+
+    return dirty;
+}
+
+QPixmap QLinuxFbDrmScreen::grabWindow(WId wid, int x, int y, int width, int height) const
+{
+    Q_UNUSED(wid);
+    Q_UNUSED(x);
+    Q_UNUSED(y);
+    Q_UNUSED(width);
+    Q_UNUSED(height);
+
+    return QPixmap();
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qlinuxfbdrmscreen.h b/src/plugins/platforms/androidmini/qlinuxfbdrmscreen.h
new file mode 100755
index 0000000..50a9576
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qlinuxfbdrmscreen.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QLINUXFBDRMSCREEN_H
+#define QLINUXFBDRMSCREEN_H
+
+#include <QtFbSupport/private/qfbscreen_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QKmsScreenConfig;
+class QLinuxFbDevice;
+
+class QLinuxFbDrmScreen : public QFbScreen
+{
+    Q_OBJECT
+public:
+    QLinuxFbDrmScreen(const QStringList &args);
+    ~QLinuxFbDrmScreen();
+
+    bool initialize() override;
+    QRegion doRedraw() override;
+    QPixmap grabWindow(WId wid, int x, int y, int width, int height) const override;
+
+private:
+    QKmsScreenConfig *m_screenConfig;
+    QLinuxFbDevice *m_device;
+};
+
+QT_END_NAMESPACE
+
+#endif // QLINUXFBDRMSCREEN_H
diff --git a/src/plugins/platforms/androidmini/qlinuxfbintegration.cpp b/src/plugins/platforms/androidmini/qlinuxfbintegration.cpp
new file mode 100755
index 0000000..b1de834
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qlinuxfbintegration.cpp
@@ -0,0 +1,260 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qlinuxfbintegration.h"
+
+#include <QOpenGLContext>
+#include <QtEglSupport/private/qeglpbuffer_p.h>
+#include "qandroidplatformopenglcontext.h"
+#include "qandroidplatformopenglwindow.h"
+#include "qandroidplatformbackingstore.h"
+
+
+#include <QtFontDatabaseSupport/private/qgenericunixfontdatabase_p.h>
+#include <QtServiceSupport/private/qgenericunixservices_p.h>
+#include <QtEventDispatcherSupport/private/qgenericunixeventdispatcher_p.h>
+
+#include <QtFbSupport/private/qfbvthandler_p.h>
+#include <QtFbSupport/private/qfbbackingstore_p.h>
+#include <QtFbSupport/private/qfbwindow_p.h>
+#include <QtFbSupport/private/qfbcursor_p.h>
+
+#include <QtGui/private/qguiapplication_p.h>
+#include <qpa/qplatforminputcontextfactory_p.h>
+
+#if QT_CONFIG(libinput)
+#include <QtInputSupport/private/qlibinputhandler_p.h>
+#endif
+
+#if QT_CONFIG(evdev)
+#include <QtInputSupport/private/qevdevmousemanager_p.h>
+#include <QtInputSupport/private/qevdevkeyboardmanager_p.h>
+#include <QtInputSupport/private/qevdevtouchmanager_p.h>
+#endif
+
+#if QT_CONFIG(tslib)
+#include <QtInputSupport/private/qtslib_p.h>
+#endif
+
+#if QT_CONFIG(kms)
+#include "qlinuxfbdrmscreen.h"
+#endif
+
+#include <QtGui/QOffscreenSurface>
+#include "qandroidplatformoffscreensurface.h"
+
+#include <QtPlatformHeaders/QEGLNativeContext>
+#define NO_ANDROID_PLUGIN
+
+QT_BEGIN_NAMESPACE
+
+int QLinuxFbIntegration::m_defaultGeometryWidth = 720;
+int QLinuxFbIntegration::m_defaultGeometryHeight = 1280;
+int QLinuxFbIntegration::m_defaultScreenWidth = 720;
+int QLinuxFbIntegration::m_defaultScreenHeight = 1280;
+int QLinuxFbIntegration::m_defaultPhysicalSizeWidth = 50;
+int QLinuxFbIntegration::m_defaultPhysicalSizeHeight = 71;
+
+Qt::ScreenOrientation QLinuxFbIntegration::m_orientation = Qt::PrimaryOrientation;
+Qt::ScreenOrientation QLinuxFbIntegration::m_nativeOrientation = Qt::PrimaryOrientation;
+
+QLinuxFbIntegration::QLinuxFbIntegration(const QStringList &paramList)
+    : m_primaryScreen(nullptr),
+      m_fontDb(new QGenericUnixFontDatabase),
+      m_services(new QGenericUnixServices)
+{
+#if QT_CONFIG(kms)
+    if (qEnvironmentVariableIntValue("QT_QPA_FB_DRM") != 0)
+        m_primaryScreen = new QLinuxFbDrmScreen(paramList);
+#endif
+	if (!m_primaryScreen)
+#ifdef USE_LINUXFB
+		m_primaryScreen = new QLinuxFbScreen(paramList);
+#else
+		m_primaryScreen = new QAndroidPlatformScreen();
+#endif
+}
+
+QLinuxFbIntegration::~QLinuxFbIntegration()
+{
+	if (m_eglDisplay != EGL_NO_DISPLAY)
+        eglTerminate(m_eglDisplay);
+
+    destroyScreen(m_primaryScreen);
+}
+
+void QLinuxFbIntegration::initialize()
+{
+    m_eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (Q_UNLIKELY(m_eglDisplay == EGL_NO_DISPLAY))
+        qFatal("Could not open egl display");
+
+    EGLint major, minor;
+    if (Q_UNLIKELY(!eglInitialize(m_eglDisplay, &major, &minor)))
+        qFatal("Could not initialize egl display");
+
+    if (Q_UNLIKELY(!eglBindAPI(EGL_OPENGL_ES_API)))
+        qFatal("Could not bind GL_ES API");
+
+
+    screenAdded(m_primaryScreen);
+
+	m_mainThread = QThread::currentThread();
+
+    m_inputContext = QPlatformInputContextFactory::create();
+
+    m_nativeInterface.reset(new QPlatformNativeInterface);
+
+    m_vtHandler.reset(new QFbVtHandler);
+
+    if (!qEnvironmentVariableIntValue("QT_QPA_FB_DISABLE_INPUT"))
+        createInputHandlers();
+}
+
+bool QLinuxFbIntegration::hasCapability(QPlatformIntegration::Capability cap) const
+{
+    switch (cap) {
+    case ThreadedPixmaps: return true;
+    case WindowManagement: return false;
+#ifndef QT_NO_OPENGL
+    case OpenGL: return true;
+    case ThreadedOpenGL: return true;
+    case RasterGLSurface: return true;
+#else
+    case OpenGL: return false;
+    case ThreadedOpenGL: return false;
+    case RasterGLSurface: return false;
+#endif
+     default: return QPlatformIntegration::hasCapability(cap);
+    }
+}
+
+QPlatformBackingStore *QLinuxFbIntegration::createPlatformBackingStore(QWindow *window) const
+{
+    return new QAndroidPlatformBackingStore(window);
+}
+
+QPlatformWindow *QLinuxFbIntegration::createPlatformWindow(QWindow *window) const
+{
+	return new QAndroidPlatformOpenGLWindow(window, m_eglDisplay);
+}
+
+QAbstractEventDispatcher *QLinuxFbIntegration::createEventDispatcher() const
+{
+    return createUnixEventDispatcher();
+}
+
+QPlatformOpenGLContext *QLinuxFbIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
+{
+    QSurfaceFormat format(context->format());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+    auto ctx = new QAndroidPlatformOpenGLContext(format, context->shareHandle(), m_eglDisplay, context->nativeHandle());
+    context->setNativeHandle(QVariant::fromValue<QEGLNativeContext>(QEGLNativeContext(ctx->eglContext(), m_eglDisplay)));
+    return ctx;
+}
+
+QPlatformOffscreenSurface *QLinuxFbIntegration::createPlatformOffscreenSurface(QOffscreenSurface *surface) const
+{
+    QSurfaceFormat format(surface->requestedFormat());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+
+    if (surface->nativeHandle()) {
+        // Adopt existing offscreen Surface
+        // The expectation is that nativeHandle is an ANativeWindow* representing
+        // an android.view.Surface
+        return new QAndroidPlatformOffscreenSurface(m_eglDisplay, format, surface);
+    }
+
+    return new QEGLPbuffer(m_eglDisplay, format, surface);
+}
+
+QList<QPlatformScreen *> QLinuxFbIntegration::screens() const
+{
+    QList<QPlatformScreen *> list;
+    list.append(m_primaryScreen);
+    return list;
+}
+
+QPlatformFontDatabase *QLinuxFbIntegration::fontDatabase() const
+{
+    return m_fontDb.data();
+}
+
+QPlatformServices *QLinuxFbIntegration::services() const
+{
+    return m_services.data();
+}
+
+void QLinuxFbIntegration::createInputHandlers()
+{
+#if QT_CONFIG(libinput)
+    if (!qEnvironmentVariableIntValue("QT_QPA_FB_NO_LIBINPUT")) {
+        new QLibInputHandler(QLatin1String("libinput"), QString());
+        return;
+    }
+#endif
+
+#if QT_CONFIG(tslib)
+    bool useTslib = qEnvironmentVariableIntValue("QT_QPA_FB_TSLIB");
+    if (useTslib)
+        new QTsLibMouseHandler(QLatin1String("TsLib"), QString());
+#endif
+
+#if QT_CONFIG(evdev)
+    new QEvdevKeyboardManager(QLatin1String("EvdevKeyboard"), QString(), this);
+    new QEvdevMouseManager(QLatin1String("EvdevMouse"), QString(), this);
+#if QT_CONFIG(tslib)
+    if (!useTslib)
+#endif
+        new QEvdevTouchManager(QLatin1String("EvdevTouch"), QString() /* spec */, this);
+#endif
+}
+
+QPlatformNativeInterface *QLinuxFbIntegration::nativeInterface() const
+{
+    return m_nativeInterface.data();
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/androidmini/qlinuxfbintegration.h b/src/plugins/platforms/androidmini/qlinuxfbintegration.h
new file mode 100755
index 0000000..3e76dd9
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qlinuxfbintegration.h
@@ -0,0 +1,121 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QLINUXFBINTEGRATION_H
+#define QLINUXFBINTEGRATION_H
+
+#include <EGL/egl.h>
+#include <qpa/qplatformintegration.h>
+#include <qpa/qplatformnativeinterface.h>
+
+#ifdef USE_LINUXFB
+#include "qlinuxfbscreen.h"
+#else
+#include "qandroidplatformscreen.h"
+#endif
+
+#include <memory>
+
+QT_BEGIN_NAMESPACE
+
+class QAbstractEventDispatcher;
+class QFbScreen;
+class QFbVtHandler;
+
+class QLinuxFbIntegration : public QPlatformIntegration, public QPlatformNativeInterface
+{
+public:
+    QLinuxFbIntegration(const QStringList &paramList);
+    ~QLinuxFbIntegration();
+
+    void initialize() Q_DECL_OVERRIDE;
+    bool hasCapability(QPlatformIntegration::Capability cap) const Q_DECL_OVERRIDE;
+
+    QPlatformWindow *createPlatformWindow(QWindow *window) const Q_DECL_OVERRIDE;
+    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const Q_DECL_OVERRIDE;
+
+    QAbstractEventDispatcher *createEventDispatcher() const Q_DECL_OVERRIDE;
+
+	QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const override;
+	
+	QPlatformOffscreenSurface *createPlatformOffscreenSurface(QOffscreenSurface *surface) const;
+
+    QPlatformFontDatabase *fontDatabase() const Q_DECL_OVERRIDE;
+    QPlatformServices *services() const Q_DECL_OVERRIDE;
+    QPlatformInputContext *inputContext() const Q_DECL_OVERRIDE { return m_inputContext; }
+
+    QPlatformNativeInterface *nativeInterface() const Q_DECL_OVERRIDE;
+
+    QList<QPlatformScreen *> screens() const;
+
+    QThread *m_mainThread;
+
+	static int m_defaultGeometryWidth;
+    static int m_defaultGeometryHeight;
+    static int m_defaultPhysicalSizeWidth;
+    static int m_defaultPhysicalSizeHeight;
+    static int m_defaultScreenWidth;
+    static int m_defaultScreenHeight;
+
+	static int test_fb;
+
+    static Qt::ScreenOrientation m_orientation;
+    static Qt::ScreenOrientation m_nativeOrientation;
+
+private:
+    EGLDisplay m_eglDisplay;
+    void createInputHandlers();
+
+
+#ifdef USE_LINUXFB
+    QFbScreen *m_primaryScreen;  //modify by chapin
+#else
+	QAndroidPlatformScreen *m_primaryScreen;
+#endif
+    QPlatformInputContext *m_inputContext;
+    QScopedPointer<QPlatformFontDatabase> m_fontDb;
+	//QPlatformFontDatabase *m_androidFDB;
+    QScopedPointer<QPlatformServices> m_services;
+    QScopedPointer<QFbVtHandler> m_vtHandler;
+    QScopedPointer<QPlatformNativeInterface> m_nativeInterface;
+};
+
+QT_END_NAMESPACE
+
+#endif // QLINUXFBINTEGRATION_H
diff --git a/src/plugins/platforms/androidmini/qlinuxfbscreen.cpp b/src/plugins/platforms/androidmini/qlinuxfbscreen.cpp
new file mode 100644
index 0000000..dc7ea08
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qlinuxfbscreen.cpp
@@ -0,0 +1,450 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qlinuxfbscreen.h"
+#include <QtFbSupport/private/qfbcursor_p.h>
+#include <QtFbSupport/private/qfbwindow_p.h>
+#include <QtCore/QFile>
+#include <QtCore/QRegularExpression>
+#include <QtGui/QPainter>
+
+#include <private/qcore_unix_p.h> // overrides QT_OPEN
+#include <qimage.h>
+#include <qdebug.h>
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <linux/kd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include <limits.h>
+#include <signal.h>
+
+#include <linux/fb.h>
+
+QT_BEGIN_NAMESPACE
+
+static int openFramebufferDevice(const QString &dev)
+{
+    int fd = -1;
+
+    if (access(dev.toLatin1().constData(), R_OK|W_OK) == 0)
+        fd = QT_OPEN(dev.toLatin1().constData(), O_RDWR);
+
+    if (fd == -1) {
+        if (access(dev.toLatin1().constData(), R_OK) == 0)
+            fd = QT_OPEN(dev.toLatin1().constData(), O_RDONLY);
+    }
+
+    return fd;
+}
+
+static int determineDepth(const fb_var_screeninfo &vinfo)
+{
+    int depth = vinfo.bits_per_pixel;
+    if (depth== 24) {
+        depth = vinfo.red.length + vinfo.green.length + vinfo.blue.length;
+        if (depth <= 0)
+            depth = 24; // reset if color component lengths are not reported
+    } else if (depth == 16) {
+        depth = vinfo.red.length + vinfo.green.length + vinfo.blue.length;
+        if (depth <= 0)
+            depth = 16;
+    }
+    return depth;
+}
+
+static QRect determineGeometry(const fb_var_screeninfo &vinfo, const QRect &userGeometry)
+{
+    int xoff = vinfo.xoffset;
+    int yoff = vinfo.yoffset;
+    int w, h;
+    if (userGeometry.isValid()) {
+        w = userGeometry.width();
+        h = userGeometry.height();
+        if ((uint)w > vinfo.xres)
+            w = vinfo.xres;
+        if ((uint)h > vinfo.yres)
+            h = vinfo.yres;
+
+        int xxoff = userGeometry.x(), yyoff = userGeometry.y();
+        if (xxoff != 0 || yyoff != 0) {
+            if (xxoff < 0 || xxoff + w > (int)(vinfo.xres))
+                xxoff = vinfo.xres - w;
+            if (yyoff < 0 || yyoff + h > (int)(vinfo.yres))
+                yyoff = vinfo.yres - h;
+            xoff += xxoff;
+            yoff += yyoff;
+        } else {
+            xoff += (vinfo.xres - w)/2;
+            yoff += (vinfo.yres - h)/2;
+        }
+    } else {
+        w = vinfo.xres;
+        h = vinfo.yres;
+    }
+
+    if (w == 0 || h == 0) {
+        qWarning("Unable to find screen geometry, using 320x240");
+        w = 320;
+        h = 240;
+    }
+
+    return QRect(xoff, yoff, w, h);
+}
+
+static QSizeF determinePhysicalSize(const fb_var_screeninfo &vinfo, const QSize &mmSize, const QSize &res)
+{
+    int mmWidth = mmSize.width(), mmHeight = mmSize.height();
+
+    if (mmWidth <= 0 && mmHeight <= 0) {
+        if (vinfo.width != 0 && vinfo.height != 0
+            && vinfo.width != UINT_MAX && vinfo.height != UINT_MAX) {
+            mmWidth = vinfo.width;
+            mmHeight = vinfo.height;
+        } else {
+            const int dpi = 100;
+            mmWidth = qRound(res.width() * 25.4 / dpi);
+            mmHeight = qRound(res.height() * 25.4 / dpi);
+        }
+    } else if (mmWidth > 0 && mmHeight <= 0) {
+        mmHeight = res.height() * mmWidth/res.width();
+    } else if (mmHeight > 0 && mmWidth <= 0) {
+        mmWidth = res.width() * mmHeight/res.height();
+    }
+
+    return QSize(mmWidth, mmHeight);
+}
+
+static QImage::Format determineFormat(const fb_var_screeninfo &info, int depth)
+{
+    const fb_bitfield rgba[4] = { info.red, info.green,
+                                  info.blue, info.transp };
+
+    QImage::Format format = QImage::Format_Invalid;
+
+    switch (depth) {
+    case 32: {
+        const fb_bitfield argb8888[4] = {{16, 8, 0}, {8, 8, 0},
+                                         {0, 8, 0}, {24, 8, 0}};
+        const fb_bitfield abgr8888[4] = {{0, 8, 0}, {8, 8, 0},
+                                         {16, 8, 0}, {24, 8, 0}};
+        if (memcmp(rgba, argb8888, 4 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_ARGB32;
+        } else if (memcmp(rgba, argb8888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB32;
+        } else if (memcmp(rgba, abgr8888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB32;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+    case 24: {
+        const fb_bitfield rgb888[4] = {{16, 8, 0}, {8, 8, 0},
+                                       {0, 8, 0}, {0, 0, 0}};
+        const fb_bitfield bgr888[4] = {{0, 8, 0}, {8, 8, 0},
+                                       {16, 8, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB888;
+        } else if (memcmp(rgba, bgr888, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB888;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+    case 18: {
+        const fb_bitfield rgb666[4] = {{12, 6, 0}, {6, 6, 0},
+                                       {0, 6, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb666, 3 * sizeof(fb_bitfield)) == 0)
+            format = QImage::Format_RGB666;
+        break;
+    }
+    case 16: {
+        const fb_bitfield rgb565[4] = {{11, 5, 0}, {5, 6, 0},
+                                       {0, 5, 0}, {0, 0, 0}};
+        const fb_bitfield bgr565[4] = {{0, 5, 0}, {5, 6, 0},
+                                       {11, 5, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb565, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB16;
+        } else if (memcmp(rgba, bgr565, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB16;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+    case 15: {
+        const fb_bitfield rgb1555[4] = {{10, 5, 0}, {5, 5, 0},
+                                        {0, 5, 0}, {15, 1, 0}};
+        const fb_bitfield bgr1555[4] = {{0, 5, 0}, {5, 5, 0},
+                                        {10, 5, 0}, {15, 1, 0}};
+        if (memcmp(rgba, rgb1555, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB555;
+        } else if (memcmp(rgba, bgr1555, 3 * sizeof(fb_bitfield)) == 0) {
+            format = QImage::Format_RGB555;
+            // pixeltype = BGRPixel;
+        }
+        break;
+    }
+    case 12: {
+        const fb_bitfield rgb444[4] = {{8, 4, 0}, {4, 4, 0},
+                                       {0, 4, 0}, {0, 0, 0}};
+        if (memcmp(rgba, rgb444, 3 * sizeof(fb_bitfield)) == 0)
+            format = QImage::Format_RGB444;
+        break;
+    }
+    case 8:
+        break;
+    case 1:
+        format = QImage::Format_Mono; //###: LSB???
+        break;
+    default:
+        break;
+    }
+
+    return format;
+}
+
+static int openTtyDevice(const QString &device)
+{
+    const char *const devs[] = { "/dev/tty0", "/dev/tty", "/dev/console", 0 };
+
+    int fd = -1;
+    if (device.isEmpty()) {
+        for (const char * const *dev = devs; *dev; ++dev) {
+            fd = QT_OPEN(*dev, O_RDWR);
+            if (fd != -1)
+                break;
+        }
+    } else {
+        fd = QT_OPEN(QFile::encodeName(device).constData(), O_RDWR);
+    }
+
+    return fd;
+}
+
+static void switchToGraphicsMode(int ttyfd, bool doSwitch, int *oldMode)
+{
+    // Do not warn if the switch fails: the ioctl fails when launching from a
+    // remote console and there is nothing we can do about it.  The matching
+    // call in resetTty should at least fail then, too, so we do no harm.
+    if (ioctl(ttyfd, KDGETMODE, oldMode) == 0) {
+        if (doSwitch && *oldMode != KD_GRAPHICS)
+            ioctl(ttyfd, KDSETMODE, KD_GRAPHICS);
+    }
+}
+
+static void resetTty(int ttyfd, int oldMode)
+{
+    ioctl(ttyfd, KDSETMODE, oldMode);
+
+    QT_CLOSE(ttyfd);
+}
+
+static void blankScreen(int fd, bool on)
+{
+    ioctl(fd, FBIOBLANK, on ? VESA_POWERDOWN : VESA_NO_BLANKING);
+}
+
+QLinuxFbScreen::QLinuxFbScreen(const QStringList &args)
+    : mArgs(args), mFbFd(-1), mTtyFd(-1), mBlitter(0)
+{
+    mMmap.data = 0;
+}
+
+QLinuxFbScreen::~QLinuxFbScreen()
+{
+    if (mFbFd != -1) {
+        if (mMmap.data)
+            munmap(mMmap.data - mMmap.offset, mMmap.size);
+        close(mFbFd);
+    }
+
+    if (mTtyFd != -1)
+        resetTty(mTtyFd, mOldTtyMode);
+
+    delete mBlitter;
+}
+
+bool QLinuxFbScreen::initialize()
+{
+    QRegularExpression ttyRx(QLatin1String("tty=(.*)"));
+    QRegularExpression fbRx(QLatin1String("fb=(.*)"));
+    QRegularExpression mmSizeRx(QLatin1String("mmsize=(\\d+)x(\\d+)"));
+    QRegularExpression sizeRx(QLatin1String("size=(\\d+)x(\\d+)"));
+    QRegularExpression offsetRx(QLatin1String("offset=(\\d+)x(\\d+)"));
+
+    QString fbDevice, ttyDevice;
+    QSize userMmSize;
+    QRect userGeometry;
+    bool doSwitchToGraphicsMode = true;
+
+    // Parse arguments
+    for (const QString &arg : qAsConst(mArgs)) {
+        QRegularExpressionMatch match;
+        if (arg == QLatin1String("nographicsmodeswitch"))
+            doSwitchToGraphicsMode = false;
+        else if (arg.contains(mmSizeRx, &match))
+            userMmSize = QSize(match.captured(1).toInt(), match.captured(2).toInt());
+        else if (arg.contains(sizeRx, &match))
+            userGeometry.setSize(QSize(match.captured(1).toInt(), match.captured(2).toInt()));
+        else if (arg.contains(offsetRx, &match))
+            userGeometry.setTopLeft(QPoint(match.captured(1).toInt(), match.captured(2).toInt()));
+        else if (arg.contains(ttyRx, &match))
+            ttyDevice = match.captured(1);
+        else if (arg.contains(fbRx, &match))
+            fbDevice = match.captured(1);
+    }
+
+    if (fbDevice.isEmpty()) {
+        fbDevice = QLatin1String("/dev/fb0");
+        if (!QFile::exists(fbDevice))
+            fbDevice = QLatin1String("/dev/graphics/fb0");
+        if (!QFile::exists(fbDevice)) {
+            qWarning("Unable to figure out framebuffer device. Specify it manually.");
+            return false;
+        }
+    }
+
+    // Open the device
+    mFbFd = openFramebufferDevice(fbDevice);
+    if (mFbFd == -1) {
+        qErrnoWarning(errno, "Failed to open framebuffer %s", qPrintable(fbDevice));
+        return false;
+    }
+
+    // Read the fixed and variable screen information
+    fb_fix_screeninfo finfo;
+    fb_var_screeninfo vinfo;
+    memset(&vinfo, 0, sizeof(vinfo));
+    memset(&finfo, 0, sizeof(finfo));
+
+    if (ioctl(mFbFd, FBIOGET_FSCREENINFO, &finfo) != 0) {
+        qErrnoWarning(errno, "Error reading fixed information");
+        return false;
+    }
+
+    if (ioctl(mFbFd, FBIOGET_VSCREENINFO, &vinfo)) {
+        qErrnoWarning(errno, "Error reading variable information");
+        return false;
+    }
+
+    mDepth = determineDepth(vinfo);
+    mBytesPerLine = finfo.line_length;
+    QRect geometry = determineGeometry(vinfo, userGeometry);
+    mGeometry = QRect(QPoint(0, 0), geometry.size());
+    mFormat = determineFormat(vinfo, mDepth);
+    mPhysicalSize = determinePhysicalSize(vinfo, userMmSize, geometry.size());
+
+    // mmap the framebuffer
+    mMmap.size = finfo.smem_len;
+    uchar *data = (unsigned char *)mmap(0, mMmap.size, PROT_READ | PROT_WRITE, MAP_SHARED, mFbFd, 0);
+    if ((long)data == -1) {
+        qErrnoWarning(errno, "Failed to mmap framebuffer");
+        return false;
+    }
+
+    mMmap.offset = geometry.y() * mBytesPerLine + geometry.x() * mDepth / 8;
+    mMmap.data = data + mMmap.offset;
+
+    QFbScreen::initializeCompositor();
+    mFbScreenImage = QImage(mMmap.data, geometry.width(), geometry.height(), mBytesPerLine, mFormat);
+
+    mCursor = new QFbCursor(this);
+
+    mTtyFd = openTtyDevice(ttyDevice);
+    if (mTtyFd == -1)
+        qErrnoWarning(errno, "Failed to open tty");
+
+    switchToGraphicsMode(mTtyFd, doSwitchToGraphicsMode, &mOldTtyMode);
+    blankScreen(mFbFd, false);
+
+    return true;
+}
+
+QRegion QLinuxFbScreen::doRedraw()
+{
+    QRegion touched = QFbScreen::doRedraw();
+
+    if (touched.isEmpty())
+        return touched;
+
+    if (!mBlitter)
+        mBlitter = new QPainter(&mFbScreenImage);
+
+    mBlitter->setCompositionMode(QPainter::CompositionMode_Source);
+    for (const QRect &rect : touched)
+        mBlitter->drawImage(rect, mScreenImage, rect);
+
+    return touched;
+}
+
+// grabWindow() grabs "from the screen" not from the backingstores.
+// In linuxfb's case it will also include the mouse cursor.
+QPixmap QLinuxFbScreen::grabWindow(WId wid, int x, int y, int width, int height) const
+{
+    if (!wid) {
+        if (width < 0)
+            width = mFbScreenImage.width() - x;
+        if (height < 0)
+            height = mFbScreenImage.height() - y;
+        return QPixmap::fromImage(mFbScreenImage).copy(x, y, width, height);
+    }
+
+    QFbWindow *window = windowForId(wid);
+    if (window) {
+        const QRect geom = window->geometry();
+        if (width < 0)
+            width = geom.width() - x;
+        if (height < 0)
+            height = geom.height() - y;
+        QRect rect(geom.topLeft() + QPoint(x, y), QSize(width, height));
+        rect &= window->geometry();
+        return QPixmap::fromImage(mFbScreenImage).copy(rect);
+    }
+
+    return QPixmap();
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/plugins/platforms/androidmini/qlinuxfbscreen.h b/src/plugins/platforms/androidmini/qlinuxfbscreen.h
new file mode 100644
index 0000000..c7ce455e
--- /dev/null
+++ b/src/plugins/platforms/androidmini/qlinuxfbscreen.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QLINUXFBSCREEN_H
+#define QLINUXFBSCREEN_H
+
+#include <QtFbSupport/private/qfbscreen_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QPainter;
+class QFbCursor;
+
+class QLinuxFbScreen : public QFbScreen
+{
+    Q_OBJECT
+public:
+    QLinuxFbScreen(const QStringList &args);
+    ~QLinuxFbScreen();
+
+    bool initialize() override;
+
+    QPixmap grabWindow(WId wid, int x, int y, int width, int height) const override;
+
+    QRegion doRedraw() override;
+
+private:
+    QStringList mArgs;
+    int mFbFd;
+    int mTtyFd;
+
+    QImage mFbScreenImage;
+    int mBytesPerLine;
+    int mOldTtyMode;
+
+    struct {
+        uchar *data;
+        int offset, size;
+    } mMmap;
+
+    QPainter *mBlitter;
+};
+
+QT_END_NAMESPACE
+
+#endif // QLINUXFBSCREEN_H
+
diff --git a/src/plugins/platforms/androidmini/view.h b/src/plugins/platforms/androidmini/view.h
new file mode 100755
index 0000000..c67c31f
--- /dev/null
+++ b/src/plugins/platforms/androidmini/view.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2014, Qualcomm Technologies, Inc. All Rights Reserved.
+ * Qualcomm Technologies Proprietary and Confidential.
+ */
+#ifndef __VIEW__
+#define __VIEW__
+#include "common.h"
+
+/**For surface*/
+#if defined(ANDROID)
+//#include <SkBitmap.h>
+//#include <SkCanvas.h>
+//#include <SkColor.h>
+//#include <SkPaint.h>
+//#include <SkTypeface.h>
+
+#include <SkStream.h>
+//#include <android/native_window.h>
+#elif defined(NO_UI)
+/*TBD*/
+#elif defined(USE_LIBMINIUI)
+/*TBD*/
+#else
+#endif
+
+#include <utils/Errors.h>
+#include <utils/Log.h>
+
+using namespace android;
+
+#endif
diff --git a/src/plugins/platforms/linuxfb/linuxfb.pro b/src/plugins/platforms/linuxfb/linuxfb.pro
index d3a4476..4154515 100644
--- a/src/plugins/platforms/linuxfb/linuxfb.pro
+++ b/src/plugins/platforms/linuxfb/linuxfb.pro
@@ -5,17 +5,19 @@ DEFINES += QT_NO_FOREACH
 QT += \
     core-private gui-private \
     service_support-private eventdispatcher_support-private \
-    fontdatabase_support-private fb_support-private
+    fontdatabase_support-private fb_support-private egl_support-private
 
 qtHaveModule(input_support-private): \
     QT += input_support-private
 
 SOURCES = main.cpp \
           qlinuxfbintegration.cpp \
-          qlinuxfbscreen.cpp
+          qlinuxfbscreen.cpp \
+          qlinuxfbopenglcontext.cpp \
 
 HEADERS = qlinuxfbintegration.h \
-          qlinuxfbscreen.h
+          qlinuxfbscreen.h \
+          qlinuxfbopenglcontext.h
 
 qtHaveModule(kms_support-private) {
     QT += kms_support-private
diff --git a/src/plugins/platforms/linuxfb/qlinuxfbintegration.cpp b/src/plugins/platforms/linuxfb/qlinuxfbintegration.cpp
index f835dbf..961c4eb 100644
--- a/src/plugins/platforms/linuxfb/qlinuxfbintegration.cpp
+++ b/src/plugins/platforms/linuxfb/qlinuxfbintegration.cpp
@@ -38,11 +38,13 @@
 ****************************************************************************/
 
 #include "qlinuxfbintegration.h"
+#include "qlinuxfbopenglcontext.h"
 #include "qlinuxfbscreen.h"
 #if QT_CONFIG(kms)
 #include "qlinuxfbdrmscreen.h"
 #endif
 
+#include <QtEglSupport/private/qeglpbuffer_p.h>
 #include <QtFontDatabaseSupport/private/qgenericunixfontdatabase_p.h>
 #include <QtServiceSupport/private/qgenericunixservices_p.h>
 #include <QtEventDispatcherSupport/private/qgenericunixeventdispatcher_p.h>
@@ -54,6 +56,7 @@
 
 #include <QtGui/private/qguiapplication_p.h>
 #include <qpa/qplatforminputcontextfactory_p.h>
+#include <QtPlatformHeaders/QEGLNativeContext>
 
 #if QT_CONFIG(libinput)
 #include <QtInputSupport/private/qlibinputhandler_p.h>
@@ -86,11 +89,25 @@ QLinuxFbIntegration::QLinuxFbIntegration(const QStringList &paramList)
 
 QLinuxFbIntegration::~QLinuxFbIntegration()
 {
+    if (m_eglDisplay != EGL_NO_DISPLAY)
+        eglTerminate(m_eglDisplay);
+
     destroyScreen(m_primaryScreen);
 }
 
 void QLinuxFbIntegration::initialize()
 {
+    m_eglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (Q_UNLIKELY(m_eglDisplay == EGL_NO_DISPLAY))
+        qFatal("Could not open egl display");
+
+    EGLint major, minor;
+    if (Q_UNLIKELY(!eglInitialize(m_eglDisplay, &major, &minor)))
+        qFatal("Could not initialize egl display");
+
+    if (Q_UNLIKELY(!eglBindAPI(EGL_OPENGL_ES_API)))
+        qFatal("Could not bind GL_ES API");
+
     if (m_primaryScreen->initialize())
         screenAdded(m_primaryScreen);
     else
@@ -125,6 +142,37 @@ QPlatformWindow *QLinuxFbIntegration::createPlatformWindow(QWindow *window) cons
     return new QFbWindow(window);
 }
 
+QPlatformOpenGLContext *QLinuxFbIntegration::createPlatformOpenGLContext(QOpenGLContext *context) const
+{
+    QSurfaceFormat format(context->format());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+    auto ctx = new QLinuxFbOpenGLContext(format, context->shareHandle(), m_eglDisplay, context->nativeHandle());
+    context->setNativeHandle(QVariant::fromValue<QEGLNativeContext>(QEGLNativeContext(ctx->eglContext(), m_eglDisplay)));
+    return ctx;
+}
+
+QPlatformOffscreenSurface *QLinuxFbIntegration::createPlatformOffscreenSurface(QOffscreenSurface *surface) const
+{
+    QSurfaceFormat format(surface->requestedFormat());
+    format.setAlphaBufferSize(8);
+    format.setRedBufferSize(8);
+    format.setGreenBufferSize(8);
+    format.setBlueBufferSize(8);
+
+    if (surface->nativeHandle()) {
+        // Adopt existing offscreen Surface
+        // The expectation is that nativeHandle is an ANativeWindow* representing
+        // an android.view.Surface
+		qDebug("native handle not support\n");
+        //return new QAndroidPlatformOffscreenSurface(m_eglDisplay, format, surface);
+    }
+
+    return new QEGLPbuffer(m_eglDisplay, format, surface);
+}
+
 QAbstractEventDispatcher *QLinuxFbIntegration::createEventDispatcher() const
 {
     return createUnixEventDispatcher();
diff --git a/src/plugins/platforms/linuxfb/qlinuxfbintegration.h b/src/plugins/platforms/linuxfb/qlinuxfbintegration.h
index 9934a8c..f25f6e4 100644
--- a/src/plugins/platforms/linuxfb/qlinuxfbintegration.h
+++ b/src/plugins/platforms/linuxfb/qlinuxfbintegration.h
@@ -40,9 +40,17 @@
 #ifndef QLINUXFBINTEGRATION_H
 #define QLINUXFBINTEGRATION_H
 
+#include <EGL/egl.h>
 #include <qpa/qplatformintegration.h>
 #include <qpa/qplatformnativeinterface.h>
 
+#include <qpa/qplatformoffscreensurface.h>
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+#include <QtGui/QOffscreenSurface>
+#include <QtEglSupport/private/qeglconvenience_p.h>
+
+
 QT_BEGIN_NAMESPACE
 
 class QAbstractEventDispatcher;
@@ -61,6 +69,10 @@ public:
     QPlatformWindow *createPlatformWindow(QWindow *window) const Q_DECL_OVERRIDE;
     QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const Q_DECL_OVERRIDE;
 
+	QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const override;
+	
+	QPlatformOffscreenSurface *createPlatformOffscreenSurface(QOffscreenSurface *surface) const;
+
     QAbstractEventDispatcher *createEventDispatcher() const Q_DECL_OVERRIDE;
 
     QPlatformFontDatabase *fontDatabase() const Q_DECL_OVERRIDE;
@@ -72,6 +84,7 @@ public:
     QList<QPlatformScreen *> screens() const;
 
 private:
+	EGLDisplay m_eglDisplay;
     void createInputHandlers();
 
     QFbScreen *m_primaryScreen;
diff --git a/src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.cpp b/src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.cpp
new file mode 100755
index 0000000..3bbfdfd
--- /dev/null
+++ b/src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.cpp
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qlinuxfbopenglcontext.h"
+#include "qlinuxfbintegration.h"
+
+#include <QtEglSupport/private/qeglpbuffer_p.h>
+
+#include <QSurface>
+#include <QtGui/private/qopenglcontext_p.h>
+#include <QtGui/QOffscreenSurface>
+
+QT_BEGIN_NAMESPACE
+
+QLinuxFbOpenGLContext::QLinuxFbOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display,
+                                                             const QVariant &nativeHandle)
+    :QEGLPlatformContext(format, share, display, nullptr, nativeHandle)
+{
+}
+
+void QLinuxFbOpenGLContext::swapBuffers(QPlatformSurface *surface)
+{
+}
+
+bool QLinuxFbOpenGLContext::makeCurrent(QPlatformSurface *surface)
+{
+    return QEGLPlatformContext::makeCurrent(surface);
+}
+
+EGLSurface QLinuxFbOpenGLContext::eglSurfaceForPlatformSurface(QPlatformSurface *surface)
+{
+
+    if (surface->surface()->surfaceClass() == QSurface::Window) {
+		qDebug("window surface not support\n");
+    } else {
+        auto platformOffscreenSurface = static_cast<QPlatformOffscreenSurface*>(surface);
+        return static_cast<QEGLPbuffer *>(surface)->pbuffer();
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.h b/src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.h
new file mode 100755
index 0000000..0a30805
--- /dev/null
+++ b/src/plugins/platforms/linuxfb/qlinuxfbopenglcontext.h
@@ -0,0 +1,62 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 BogDan Vatra <bogdan@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QLINUXFBOPENGLCONTEXT_H
+#define QLINUXFBOPENGLCONTEXT_H
+
+#include <QtEglSupport/private/qeglplatformcontext_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QLinuxFbOpenGLContext : public QEGLPlatformContext
+{
+public:
+    QLinuxFbOpenGLContext(const QSurfaceFormat &format, QPlatformOpenGLContext *share, EGLDisplay display, const QVariant &nativeHandle);
+    void swapBuffers(QPlatformSurface *surface) override;
+    bool makeCurrent(QPlatformSurface *surface) override;
+
+private:
+    EGLSurface eglSurfaceForPlatformSurface(QPlatformSurface *surface) override;
+
+};
+
+QT_END_NAMESPACE
+
+#endif // QANDROIDPLATFORMOPENGLCONTEXT_H
diff --git a/src/plugins/platforms/linuxfb/qlinuxfbscreen.cpp b/src/plugins/platforms/linuxfb/qlinuxfbscreen.cpp
index dc7ea08..c85817e 100644
--- a/src/plugins/platforms/linuxfb/qlinuxfbscreen.cpp
+++ b/src/plugins/platforms/linuxfb/qlinuxfbscreen.cpp
@@ -414,7 +414,9 @@ QRegion QLinuxFbScreen::doRedraw()
 
     mBlitter->setCompositionMode(QPainter::CompositionMode_Source);
     for (const QRect &rect : touched)
+	{
         mBlitter->drawImage(rect, mScreenImage, rect);
+	}
 
     return touched;
 }
diff --git a/src/plugins/platforms/platforms.pro b/src/plugins/platforms/platforms.pro
index e618876..b171f1b 100644
--- a/src/plugins/platforms/platforms.pro
+++ b/src/plugins/platforms/platforms.pro
@@ -36,6 +36,8 @@ qtConfig(directfb) {
 
 qtConfig(linuxfb): SUBDIRS += linuxfb
 
+qtConfig(androidmini): SUBDIRS += androidmini
+
 qtHaveModule(network):qtConfig(vnc): SUBDIRS += vnc
 
 freebsd {
-- 
1.9.1

