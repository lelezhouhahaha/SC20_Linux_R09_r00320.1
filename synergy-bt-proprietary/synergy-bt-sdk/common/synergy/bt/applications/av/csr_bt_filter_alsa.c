/******************************************************************************

Copyright (c) 2009-2016 Qualcomm Technologies International, Ltd.
All Rights Reserved. 
Qualcomm Technologies International, Ltd. Confidential and Proprietary.

REVISION:      $Revision: #1 $
******************************************************************************/

#include "csr_synergy.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <getopt.h>
#include <pthread.h>
#include <signal.h>
#include "csr_sched.h"
#include "csr_pmem.h"
#include "csr_bt_util.h"
#include "csr_bt_av_prim.h"
#include "csr_bt_av_lib.h"
#include "csr_bt_cm_lib.h"
#include "csr_bt_sc_lib.h"
#include "csr_sbc_api.h"
#include "csr_bt_platform.h"
#include "csr_bt_av2.h"
#include "csr_bt_av2_filter.h"
#include "csr_app_lib.h"
#include <unistd.h>

#ifndef inline
#define inline __inline__
#endif
#include <asoundlib.h>

#ifdef CSR_LOG_ENABLE
#include "csr_log.h"
#endif

/* Settings */

#define ALSA_PRN            "alsa: "

#define BUFFER_SIZE         4096               /* Size of each buffer in bytes */
#define BUFFERS             11                 /* Number of buffers */
#define READ_FRAMES         1024               /* Try to capture this many frames (apply framesize to get size in bytes) */
#define CAPTURE_THRESHOLD   12288              /* Collect capture sample buffers of this size */
#define ALSA_TOTAL_PERIODS  2                  /* Defines total number of hardware interrupts to be generated by ALSA. */
#define ALSA_TOTAL_BUFFER_SIZE_FRAMES  4410    /* Total Size of buffer to be allocated by ALSA for the PCM port */

/* Playback time (milli seconds) */
#define PLAYBACK_BUFFER_TIME 140

/* #define DEBUG */
/* #define VERBOSE_DEBUG */

#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)

#undef BUFFER_SIZE
#define BUFFER_SIZE         15360 * 4         /* Size of each buffer in bytes */
#undef BUFFERS
#define BUFFERS             8                 /* Number of buffers */
#endif

typedef struct
{
    av2filter_t           *filter;
    char                  *device;
    snd_pcm_sframes_t     framesize;
    snd_pcm_stream_t      stream;
    snd_pcm_t             *handle;
    snd_pcm_hw_params_t   *params;
    CsrUint32              sample_rate;
    CsrUint32              channels;

    CsrBool                run;
    pthread_mutex_t       mutex;
    /* this is updated to true when ALSA is free to consume more data */
    CsrBool               alsaFree;
    /* signal when pcm is waiting for more data */
    pthread_mutex_t       mutex_sig_on_alsa_free;
    pthread_cond_t        wake;
    pthread_t             thread;
    CsrUint32              errors;
    CsrBool                suspend;

    CsrUint8              *buffers[BUFFERS];
    CsrUint32              lengths[BUFFERS];
    CsrUint8               buf_in;
    CsrUint8               buf_out;
    CsrUint8               count;
    /* Total amount of buffered data */
    CsrUint32              bufferdPcmFrames;
    CsrUint32              playback_threshold_in_frames;

    CsrUint8               *capbuf;
    CsrUint32              capsize;

    CsrSchedBgint             bgint_filter;
} alsa_instance_t;

/* Filter entry prototypes */
static CsrBool alsa_init(void **instance, av2filter_t *filter, av2instance_t *av2inst);
static CsrBool alsa_deinit(void **instance);
static CsrBool alsa_open(void **instance);
static CsrBool alsa_close(void **instance);
static CsrBool alsa_start(void **instance);
static CsrBool alsa_stop(void **instance);
static CsrBool alsa_process_play(CsrUint8 index,
                                av2filter_t **chain,
                                CsrBool freeData,
                                void *data,
                                CsrUint32 length);
static CsrBool alsa_process_capture(CsrUint8 index,
                                   av2filter_t **chain,
                                   CsrBool freeData,
                                   void *data,
                                   CsrUint32 length);
static CsrUint8 *alsa_get_config(void **instance,
                                CsrUint8 *conf_len);
static CsrBtAvResult alsa_set_config(void **instance,
                                   CsrUint8 *conf,
                                   CsrUint8 conf_len);
static CsrUint8 *alsa_get_caps(void **instance,
                              CsrUint8 *cap_len);
static CsrUint8 *alsa_remote_caps(void **instance,
                                 CsrUint8 *caps,
                                 CsrUint8 caps_len,
                                 CsrUint8 *conf_len);
static void alsa_qos_update(void **instance,
                            CsrUint16 qosLevel);
static void alsa_menu(void **instance,
                      CsrUint8 *num_options);
static CsrBool alsa_setup(void **instance,
                         CsrUint8 index,
                         char *value);
static int alsa_xrun(alsa_instance_t *inst, int err);

/* Filter structure setup for ALSA playback */
av2filter_t filter_alsa_play =
{
    "csr_linux_alsa_playback",
    FILTER_CONSUMER,
    AV_NO_MEDIA,
    AV_NO_CODEC,
    0,
    NULL,
    alsa_init,
    alsa_deinit,
    alsa_open,
    alsa_close,
    alsa_start,
    alsa_stop,
    alsa_process_play,
    alsa_get_config,
    alsa_set_config,
    alsa_get_caps,
    alsa_remote_caps,
    alsa_qos_update,
    alsa_menu,
    alsa_setup,
    NULL,
};

/* Filter structure setup for ALSA capture */
av2filter_t filter_alsa_capture =
{
    "csr_linux_alsa_capture",
    FILTER_PRODUCER,
    AV_NO_MEDIA,
    AV_NO_CODEC,
    0,
    NULL,
    alsa_init,
    alsa_deinit,
    alsa_open,
    alsa_close,
    alsa_start,
    alsa_stop,
    alsa_process_capture,
    alsa_get_config,
    alsa_set_config,
    alsa_get_caps,
    alsa_remote_caps,
    alsa_qos_update,
    alsa_menu,
    alsa_setup,
    NULL,
};


int log_enable = 0;

#define LOG_PRINT(fmt, args...) {\
    if (log_enable) \
        printf(fmt, ##args); \
    else\
        do {;} while(0);\
    }

#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)
static int xrun_recovery(snd_pcm_t *handle, int err)
{
    if (err == -EPIPE)
    {
        /* under-run */
        err = snd_pcm_prepare(handle);

        if (err < 0)
            LOG_PRINT("Can't recovery from underrun, prepare failed: %s\n", snd_strerror(err));

        return 0;
    }
    else if (err == -ESTRPIPE)
    {
        while ((err = snd_pcm_resume(handle)) == -EAGAIN)
            sleep(1);       /* wait until the suspend flag is released */

        if (err < 0)
        {
            err = snd_pcm_prepare(handle);

            if (err < 0)
                LOG_PRINT("Can't recovery from suspend, prepare failed: %s\n", snd_strerror(err));
        }

        return 0;
    }

    return err;
}

static void init_amix_av_audio_for_9x50()
{
    system("amix 'SLIM RX0 MUX' 'AIF1_PB'");
    system("amix 'SLIM RX1 MUX' 'AIF1_PB'");
    system("amix 'MI2S_RX Channels' 'Two'");
    system("amix 'RX INT1_1 MIX1 INP0' 'RX0'");
    system("amix 'RX INT2_1 MIX1 INP0' 'RX1'");
    system("amix 'RX INT1 DEM MUX' 'CLSH_DSM_OUT'");
    system("amix 'RX INT2 DEM MUX' 'CLSH_DSM_OUT'");
    system("amix 'COMP1 Switch' 1");
    system("amix 'COMP2 Switch' 1");
    system("amix 'PRI_MI2S_RX Audio Mixer MultiMedia1' 1");
}

static void deinit_amix_av_audio_for_9x50()
{
    system("amix 'SLIM RX0 MUX' 0");
    system("amix 'SLIM RX1 MUX' 0");
    system("amix 'MI2S_RX Channels' 0");
    system("amix 'RX INT1_1 MIX1 INP0' 0");
    system("amix 'RX INT2_1 MIX1 INP0' 0");
    system("amix 'RX INT1 DEM MUX' '0'");
    system("amix 'RX INT2 DEM MUX' '0'");
    system("amix 'COMP1 Switch' 0");
    system("amix 'COMP2 Switch' 0");
    system("amix 'PRI_MI2S_RX Audio Mixer MultiMedia1' 0");
}


#endif

/* Process alsa playback data */
static CsrBool alsa_process_play(CsrUint8 index,
                                av2filter_t **chain,
                                CsrBool freeData,
                                void *data,
                                CsrUint32 length)
{
    alsa_instance_t *inst;
    inst = (alsa_instance_t*)(chain[index]->f_instance);
#if defined(AUDIO_FOR_MDM9650) || defined(AUDIO_FOR_IMX)
    unsigned int fill_len, left_len;
#endif

    if (length > BUFFER_SIZE)
    {
#ifdef CSR_LOG_ENABLE
        CSR_LOG_TEXT("PCM len > BUFFER_SIZE!!");
#endif
    }

#if defined(AUDIO_FOR_MDM9650) || defined(AUDIO_FOR_IMX)
    /* fill the data to inst->buffer */
    fill_len = 0;
    left_len = 0;

    if (inst->lengths[inst->buf_in] + length > BUFFER_SIZE)
    {
        left_len = inst->lengths[inst->buf_in] + length - BUFFER_SIZE;
        fill_len = BUFFER_SIZE - inst->lengths[inst->buf_in];

        CsrMemCpy(inst->buffers[inst->buf_in] + inst->lengths[inst->buf_in],
                  data,
                  fill_len);
        inst->lengths[inst->buf_in] = BUFFER_SIZE;

        /* Select next buffer and prepare to receive more data */
        inst->buf_in = (inst->buf_in + 1) % BUFFERS;
        inst->lengths[inst->buf_in] = 0;

        if (0 != left_len)
        {
            CsrMemCpy(inst->buffers[inst->buf_in],
                      data + fill_len,
                      left_len);
            inst->lengths[inst->buf_in] = left_len;

        }
    }
    else
    {
        CsrMemCpy(inst->buffers[inst->buf_in] + inst->lengths[inst->buf_in],
                  data,
                  length);
        inst->lengths[inst->buf_in] += length;
    }

#else
    else if ((inst->lengths[inst->buf_in] + length) <= BUFFER_SIZE)
    {
        /* Okay the packet arrived can be fit into the current buffer.
           So nothing to be done */
    }
    else
    {
        if (((inst->buf_in+1)%BUFFERS) == inst->buf_out)
        {
#ifdef CSR_LOG_ENABLE
            CSR_LOG_TEXT("buf_in == buf_out: possible loss of data !!");
#endif
        }

        /* The new packet cannot be fit so move to the next one */
        inst->buf_in = (inst->buf_in + 1) % BUFFERS;
        inst->lengths[inst->buf_in] = 0;
    }

    /* Put data into incoming buffer */
    CsrMemCpy(inst->buffers[inst->buf_in] + inst->lengths[inst->buf_in],
           data,
           length);
    inst->lengths[inst->buf_in] += length;
#endif

    /* Update buffered frames and wake thread if necessary */
    pthread_mutex_lock(&inst->mutex);
#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)
    inst->bufferdPcmFrames += length ;

    if (inst->bufferdPcmFrames >= 2 * BUFFER_SIZE)
    {
        LOG_PRINT("<%s>, inst->bufferdPcmFrames is %d, inst->buf_in is %d\n", __FUNCTION__, inst->bufferdPcmFrames, inst->buf_in);
        pthread_cond_signal(&inst->wake);
    }

#else
    inst->bufferdPcmFrames += (length/inst->framesize);

    if (inst->bufferdPcmFrames >= inst->playback_threshold_in_frames)
    {
        pthread_cond_signal(&inst->wake);
    }

#endif
    pthread_mutex_unlock(&inst->mutex);
#if !defined(AUDIO_FOR_MDM9650) && !defined(AUDIO_FOR_IMX)
    pthread_mutex_lock(&inst->mutex_sig_on_alsa_free);

    if (inst->alsaFree == TRUE)
    {
        /* Feed something to alsa so that it does not complain */
        inst->buf_in = (inst->buf_in + 1) % BUFFERS;
        inst->lengths[inst->buf_in] = 0;
        pthread_cond_signal(&inst->wake);
    }

    pthread_mutex_unlock(&inst->mutex_sig_on_alsa_free);
#endif

    /* Free data and trigger next stage even though data has been consumed */
    if(freeData && data)
    {
        CsrPmemFree(data);
    }

    /* Pass data on to next stage */
    return chain[index+1]->f_process(index+1,
                                     chain,
                                     FALSE,
                                     NULL,
                                     0);
}

/* ALSA playback thread */
static void *alsa_thread_play(void *instance)
{
    alsa_instance_t *inst;
    void *data;
    CsrUint32 length;
    CsrInt32 res;
    CsrInt32 frames;
    inst = (alsa_instance_t*)instance;

#ifdef DEBUG
    CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "thread begin...\n");
#endif

    res = 0;
    while(inst->run)
    {
        pthread_mutex_lock(&inst->mutex);
        while(((inst->bufferdPcmFrames == 0) || inst->suspend) && (inst->run))
        {
            /* Wait for buffer to contain enough data */
            pthread_cond_wait(&inst->wake, &inst->mutex);
            inst->suspend = FALSE;
            snd_pcm_pause(inst->handle, 0);
        }

#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)

        if (inst->bufferdPcmFrames > 0 && inst->lengths[inst->buf_out] == BUFFER_SIZE)
        {
            /* Get current out-buffer */

            data   = inst->buffers[inst->buf_out];
            length = inst->lengths[inst->buf_out];

            inst->buf_out = (inst->buf_out + 1) % BUFFERS;

            inst->bufferdPcmFrames -= length;

            LOG_PRINT("<%s>, inst->buf_out= %d, buffered left= %d\n", __FUNCTION__,
                      inst->buf_out, inst->bufferdPcmFrames);

            pthread_mutex_unlock(&inst->mutex);
        }

        else
        {
            pthread_mutex_unlock(&inst->mutex);
            inst->suspend = TRUE;
            data = NULL;
            length = 0;
            LOG_PRINT("<%s>, data is NULL\n", __FUNCTION__);
            continue;

        }


        /* If no data at this point, exit */
        if (data == NULL || length == 0)
        {
            continue;
        }

        frames = BUFFER_SIZE / 4;

        pthread_mutex_lock(&inst->mutex_sig_on_alsa_free);
        inst->alsaFree = FALSE;
        pthread_mutex_unlock(&inst->mutex_sig_on_alsa_free);

        while ( frames > 0 && data != NULL)
        {

            res = snd_pcm_writei(inst->handle,
                                 data,
                                 frames);

            LOG_PRINT("write_frames %d, consume frames consumed %d\n", frames, res);

            if (res < 0)
            {
                if (xrun_recovery(inst->handle, res) < 0)
                {
                    LOG_PRINT("Write error: %s\n", snd_strerror(res));
                    /* exit(EXIT_FAILURE); */
                }

                LOG_PRINT("play xrun happen,continue write\n");
                continue;
            }

            if (snd_pcm_state(inst->handle) == SND_PCM_STATE_RUNNING)
            {
                /* TODO */
            }

            data += res * 4;
            frames -= res;

            if (frames == 0)
            {
                LOG_PRINT("period write finished\n");
                break;
            }
        }

#else

        if(inst->bufferdPcmFrames > 0)
        {
            if (inst->buf_in == inst->buf_out)
            {
                /* Move onto the next buffer so that alsa can consume uptill the current buffer */
                inst->buf_in = (inst->buf_in + 1) % BUFFERS;
                inst->lengths[inst->buf_in] = 0;
            }

            /* Get current out-buffer */
            data   = inst->buffers[inst->buf_out];
            length = inst->lengths[inst->buf_out];
            inst->lengths[inst->buf_out] = 0;
            inst->buf_out = (inst->buf_out + 1) % BUFFERS;
            inst->bufferdPcmFrames -= (length / inst->framesize);
            pthread_mutex_unlock(&inst->mutex);
        }
        else
        {
            pthread_mutex_unlock(&inst->mutex);
            data = NULL;
            length = 0;
        }

        /* If no data at this point, exit */
        if(data == NULL)
        {
            break;
        }

        /* Send data to ALSA */
        frames = length / inst->framesize;

        pthread_mutex_lock(&inst->mutex_sig_on_alsa_free);
        inst->alsaFree = FALSE;
        pthread_mutex_unlock(&inst->mutex_sig_on_alsa_free);

        res = snd_pcm_writei(inst->handle,
                             data,
                             frames);

        pthread_mutex_lock(&inst->mutex_sig_on_alsa_free);
        inst->alsaFree = TRUE;
        pthread_mutex_unlock(&inst->mutex_sig_on_alsa_free);

        if(res < 0)
        {
            alsa_xrun(inst, res);
        }
        else if(res != frames)
        {
            CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "playback device did not consume all frames, sent %i, consumed %i\n",
                   frames, res);
            break;
        }

#endif
    }


#ifdef DEBUG
    CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "thread end...\n");
#endif
    return NULL;
}

/* ALSA xrun handler */
static int alsa_xrun(alsa_instance_t *inst, int err)
{
    int res;

    inst->errors++;
    res = 0;
    switch(err)
    {
        case -EAGAIN:
            if((inst->errors % 10) == 0)
            {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "device has more data, error count %i\n", inst->errors);
            }
            snd_pcm_wait(inst->handle, 1000);
            break;

        case -EBADFD:
            if((inst->errors % 10) == 0)
          {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "device not in right state, error count %i\n", inst->errors);
            }
            snd_pcm_prepare(inst->handle);
            break;

        case -EPIPE:
            if((inst->errors % 10) == 0)
            {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "device over/under-run, error count %i\n", inst->errors);
            }
            snd_pcm_prepare(inst->handle);
            snd_pcm_pause(inst->handle, 1);
            inst->suspend = TRUE;
#ifdef CSR_LOG_ENABLE
            CSR_LOG_TEXT("-EPIPE");
#endif
            break;

        case -ESTRPIPE:
            if((inst->errors % 10) == 0)
            {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "device suspend error, error count %i\n", inst->errors);
            }
            snd_pcm_prepare(inst->handle);
            break;

        default:
            if((inst->errors % 10) == 0)
            {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "playback thread, unknown error, code %i, error count %i\n",
                       res, inst->errors);
            }
            res = err;
            snd_pcm_prepare(inst->handle);
            break;
    }

    return res;
}

/* ALSA capture thread */
static void *alsa_thread_capture(void *instance)
{
    alsa_instance_t *inst;
    snd_pcm_sframes_t cap;

    inst = (alsa_instance_t*)instance;

    while(inst->run)
    {
        /* Capture frames */
        cap = snd_pcm_readi(inst->handle,
                            inst->buffers[inst->buf_in],
                            READ_FRAMES);
#ifdef VERBOSE_DEBUG
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "read %i frames\n", (int)cap);
#endif

        if(cap < 0)
        {
            /* Over/underruns, don't free buffer */
            alsa_xrun(inst, cap);
        }
        else
        {
            /* Update ringbuffer */
            inst->lengths[inst->buf_in] = cap * inst->framesize;
            inst->buf_in = (inst->buf_in + 1) % BUFFERS;

            pthread_mutex_lock(&inst->mutex);
            inst->count++;
            pthread_mutex_unlock(&inst->mutex);

            /* Wake up processer */
            CsrSchedBgintSet(inst->bgint_filter);
        }
    }

    return NULL;
}

/* Initialise alsa filter */
static CsrBool alsa_init(void **instance, struct av2filter_t *filter, av2instance_t *av2inst)
{
    alsa_instance_t *inst;
    CsrUint8 i;
    *instance = CsrPmemZalloc(sizeof(alsa_instance_t));
    inst = (alsa_instance_t*)*instance;

    /* Allocate things */
    snd_pcm_hw_params_malloc(&(inst->params));
    if(inst->params == NULL)
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not allocate ALSA hw_params structure\n");
        return FALSE;
    }
#ifdef DEBUG
    else
    {
        CsrMemSet(inst->params, 0, snd_pcm_hw_params_sizeof());
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "allocated hw_params structure\n");
    }
#endif

    /* Set defaults */
    inst->device = strdup(av2inst->alsa_device_name);
    inst->filter = filter;
    inst->stream = ((filter->f_type & FILTER_CONSUMER)
                    ? SND_PCM_STREAM_PLAYBACK
                    : SND_PCM_STREAM_CAPTURE);

    /* Allocate the ringbuffers */
    for(i=0; i<BUFFERS; i++)
    {
        inst->buffers[i] = CsrPmemAlloc(BUFFER_SIZE);
        inst->lengths[i] = 0;
        CsrMemSet(inst->buffers[i], 0, BUFFER_SIZE);
    }
    inst->capbuf = CsrPmemAlloc(CAPTURE_THRESHOLD);
    inst->buf_in = 0;
    inst->buf_out = 0;
    inst->count = 0;
    inst->bufferdPcmFrames = 0;
    inst->playback_threshold_in_frames = 0;

    inst->bgint_filter = CsrSchedBgintReg(filtersBackgroundInterrupt, av2inst, "alsa_filter");

    /* Initialise transfer buffer */
    pthread_mutex_init(&inst->mutex, NULL);
    pthread_cond_init(&inst->wake, NULL);

    pthread_mutex_init(&inst->mutex_sig_on_alsa_free, NULL);
    inst->alsaFree = FALSE;

#ifdef DEBUG
    CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "alsa filter initialized\n");
#endif

    return TRUE;
}

/* Deinitialise alsa filter */
static CsrBool alsa_deinit(void **instance)
{
    alsa_instance_t *inst;
    CsrUint8 i;
    inst = (alsa_instance_t*)*instance;

    CsrSchedBgintUnreg(inst->bgint_filter);

    /* Free members */
    if(inst->params != NULL)
    {
        snd_pcm_hw_params_free(inst->params);
    }
    if(inst->device != NULL)
    {
        free(inst->device);
    }
    for(i=0; i<BUFFERS; i++)
    {
        CsrPmemFree(inst->buffers[i]);
    }
        
#ifdef AUDIO_FOR_MDM9650
    /* TODO [mdm9650]Do NOT deinit amix here, it will affect HF! */
    /* deinit_amix_av_audio_for_9x50();*/
#endif
    CsrPmemFree(inst->capbuf);

    CsrPmemFree(inst);
    *instance = NULL;

    return TRUE;
}

/* Open alsa with current configuration */
static CsrBool alsa_open(void **instance)
{
    alsa_instance_t *inst;
    CsrBool result;
    CsrUint32 tmp;
    CsrUint8 bits;
    CsrUint8 chans;
    CsrUint16 freq;

#if defined(AUDIO_FOR_MDM9650) || defined(AUDIO_FOR_IMX)
    snd_pcm_uframes_t buffer_size_max, buffer_size_min, buffer_size;
    snd_pcm_uframes_t period_size_max, period_size_min, period_size;
    int dir;
#endif

    inst = (alsa_instance_t*)*instance;

#ifdef DEBUG
    CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "opening alsa filter\n");
#endif

    /* Close before reopen */
    result = TRUE;
    if(inst->handle != 0)
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "filter already open - reopening\n");
        result = alsa_close(instance);
    }

    /* Get global AV2 configuration */
    getPcmSettings(&chans, &bits, &freq);
    inst->channels = chans;
    inst->sample_rate = freq;

#ifdef  AUDIO_FOR_MDM9650
        
    init_amix_av_audio_for_9x50();

    /* Open PCM device */
    if(result && (snd_pcm_open(&(inst->handle),
                               inst->device,
                               inst->stream,
                                SND_PCM_NONBLOCK) < 0))
#else
    if (result && (snd_pcm_open(&(inst->handle),
                                inst->device,
                                inst->stream,
                               0) < 0))
#endif
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not open PCM device '%s'\n", inst->device);
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "pcm device opened, 0x%08x\n", inst->handle);
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "pcm device params, 0x%08x\n", inst->params);
    }
#endif


    /* Get config */
    if(result && (snd_pcm_hw_params_any(inst->handle,
                                        inst->params) < 0))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not get hardware parameters\n");
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "got hw parameters\n");
    }
#endif


    /* Set access mode */
    if(result && (snd_pcm_hw_params_set_access(inst->handle,
                                               inst->params,
                                               SND_PCM_ACCESS_RW_INTERLEAVED) < 0))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set access mode\n");
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "access mode set\n");
    }
#endif

    /* Set sample format (signed 16bit little endian) */
    if(result && (snd_pcm_hw_params_set_format(inst->handle,
                                               inst->params,
#ifndef __BIG_ENDIAN__
                                               SND_PCM_FORMAT_S16_LE
#else
                                               SND_PCM_FORMAT_S16_BE
#endif
                           ) < 0))
    {
#ifndef __BIG_ENDIAN__
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set PCM format (signed 16bit little endian)\n");
#else
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set PCM format (signed 16bit big endian)\n");
#endif
        result = FALSE;
    }

    /* Set sample rate */
    tmp = inst->sample_rate;
    if(result && (snd_pcm_hw_params_set_rate_near(inst->handle,
                                                  inst->params,
                                                  &tmp,
                                                  0) < 0))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set sample rate\n");
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "sample rate set\n");
    }
#endif
#ifdef AUDIO_FOR_MDM9650
    if(result && (tmp != inst->sample_rate))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "sample rate is not supported by the hardware\n");
        result = FALSE;
    }
#endif
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "actual sample rate matches requested rate\n");
    }
#endif

    /* Channels */
    if(result && (snd_pcm_hw_params_set_channels(inst->handle,
                                                 inst->params,
                                                 inst->channels) < 0))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set number of channels\n");
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "number of channels set\n");
    }
#endif
#if !defined(AUDIO_FOR_MDM9650) && !defined(AUDIO_FOR_IMX)

    /* Periods (buffers/fragments) */
    if(result && (snd_pcm_hw_params_set_periods(inst->handle,
                                                inst->params,
                                                ALSA_TOTAL_PERIODS,
                                                0) < 0))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set number of periods\n");
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "periods set\n");
    }
#endif
#endif

    /* Set buffer size. We alsays use 16 bit (2 byte) mode, but we must also take
     * account for the number of channels */
    inst->framesize = 2 * inst->channels;

#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)

    /* Set buffer size. We alsays use 16 bit (2 byte) mode, but we must also take
     * account for the number of channels */
    if (result)
    {
        snd_pcm_hw_params_get_buffer_size_max(inst->params, &buffer_size_max);
        LOG_PRINT("snd_pcm_hw_params_get_buffer_size_max: val %u\n", (CsrInt32)buffer_size_max);

        snd_pcm_hw_params_get_buffer_size_min(inst->params, &buffer_size_min);
        LOG_PRINT("snd_pcm_hw_params_get_buffer_size_min: val %u\n", (CsrInt32)buffer_size_min);

        /*buffer_size = period_size * periods / inst->framesize;*/
        buffer_size = buffer_size_max;

        if (snd_pcm_hw_params_set_buffer_size_near(inst->handle,
                                                   inst->params,
                                                   &buffer_size) < 0)
        {
            LOG_PRINT("Could not set buffer size (%i), errno %d ('%s')\n", (CsrInt32)buffer_size, errno, snd_strerror(errno));
            result = FALSE;
        }
        else
        {
            LOG_PRINT("buffer size set: %u\n", (CsrInt32)buffer_size);
        }
    }

    snd_pcm_hw_params_get_period_size_max(inst->params, &period_size_max, &dir);
    snd_pcm_hw_params_get_period_size_min(inst->params, &period_size_min, &dir);
    period_size = period_size_max;
    snd_pcm_hw_params_set_period_size_near(inst->handle,
                                           inst->params,
                                           &period_size,
                                           0) ;

    snd_pcm_get_params(inst->handle, &buffer_size, &period_size);
    LOG_PRINT("buffer_size = %d, priod_size = %d\n", buffer_size, period_size);

#else
    tmp = ALSA_TOTAL_BUFFER_SIZE_FRAMES;
    if(result && (snd_pcm_hw_params_set_buffer_size(inst->handle,
                                                    inst->params,
                                                    tmp) < 0))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set buffer size (%i)\n", tmp);
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "buffer size set\n");
    }
#endif
#endif

    /* Apply parameters */
    if(result && (snd_pcm_hw_params(inst->handle,
                                    inst->params) < 0))
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not set hw parameters\n");
        result = FALSE;
    }
#ifdef VERBOSE_DEBUG
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "parameters applied\n");
    }
#endif
    LOG_PRINT("<%s>, apply param result = %d\n", __FUNCTION__, result);

    inst->playback_threshold_in_frames = (inst->sample_rate * PLAYBACK_BUFFER_TIME)/1000;

    return result;
}

/* Close alsa configuration */
static CsrBool alsa_close(void **instance)
{
    alsa_instance_t *inst;
    int code;
    CsrBool result;
    inst = (alsa_instance_t*)*instance;

    /* Close the handle */
    result = TRUE;

    LOG_PRINT("<%s> \n", __FUNCTION__);

    if(inst->handle != 0)
    {
        code = snd_pcm_close(inst->handle);
        inst->handle = 0;
        if(code < 0)
        {
            LOG_PRINT("<%s>, alsa close error code %d\n", __FUNCTION__, code);
            CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "error closing PCM handle, code %i\n", code);
            result = FALSE;
        }
    }

    return result;
}

/* Start alsa streaming */
static CsrBool alsa_start(void **instance)
{
    alsa_instance_t *inst;
    int code;
    CsrBool result;
    inst = (alsa_instance_t*)*instance;
    
    /* Prepare the handle */
#ifdef DEBUG
    CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "preparing pcm\n");
#endif

    code = snd_pcm_prepare(inst->handle);

    if(code < 0)
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "error preparing PCM handle, code %i\n", code);
        LOG_PRINT("<%s>, alsa_start fail\n", __FUNCTION__);
        result = FALSE;
    }
    else
    {
#ifdef DEBUG
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "starting thread\n");
#endif
        inst->errors = 0;
        inst->run = TRUE;

        /* Start thread */
        if(inst->filter->f_type & FILTER_CONSUMER)
        {
            /* Playback thread */
            code = pthread_create(&inst->thread,
                                  NULL,
                                  alsa_thread_play,
                                  inst);
            if(code != 0)
            {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not start playback thread, code %i\n", code);
                result = FALSE;
            }
            else
            {
                result = TRUE;
#ifdef DEBUG
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "playback thread started\n");
#endif

            }
        }
        else
        {
            /* Capture thread */
            code = pthread_create(&inst->thread,
                                  NULL,
                                  alsa_thread_capture,
                                  inst);
            if(code != 0)
            {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "could not start capture thread, code %i\n", code);
                result = FALSE;
            }
            else
            {
                result = TRUE;
#ifdef DEBUG
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "capture thread started\n");
#endif
            }
        }
    }

#ifdef DEBUG
    CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "PCM device now streaming\n");
#endif

    return result;
}

/* Stop alsa streaming */
static CsrBool alsa_stop(void **instance)
{
    alsa_instance_t *inst;
    int code;
#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)
    CsrUint8 i;
#endif
    void *thres;
    CsrBool result;
    inst = (alsa_instance_t*)*instance;

    /* [QTI] KW issue #418175*/
    if (NULL == inst)
    {
        return FALSE;
    }

    inst->buf_in = 0;
    inst->buf_out = 0;
    inst->count = 0;
    inst->bufferdPcmFrames = 0;
 
    /* Stop thread */
    inst->run = FALSE;
    if(inst->thread != 0)
    {
        pthread_cond_broadcast(&inst->wake);
        code = pthread_join(inst->thread, &thres);
        if(code != 0)
        {
            CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "error stopping thread, code %i\n", code);
            LOG_PRINT("error stopping thread, code %d\n", code);
        }
        inst->thread = 0;
    }
    else
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "thread not running\n");
    }
#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)
    code = snd_pcm_drop(inst->handle);
    /* [mdm9650]release pcm device for HF usage, when stop music */
    code = alsa_close(instance);
#else
    /* Drain the handle */
     code = snd_pcm_drain(inst->handle); 
#endif
    if(code < 0)
    {
        CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "error draining (stopping) PCM handle, code %i\n", code);
        LOG_PRINT("error draining (stopping) PCM handle, code %d\n", code);
        result = FALSE;
    }
    else
    {
#if defined(AUDIO_FOR_MDM9650)|| defined(AUDIO_FOR_IMX)
        /* Clear the buffers so that they are not left over to next a2dp streaming */
        for (i = 0; i < BUFFERS; i++)
        {
            inst->lengths[i] = 0;
        }
#endif
        result = TRUE;
    }

    inst->alsaFree = FALSE;

    return result;
}

/* Process ALSA capture data. This function is called on behalf of
 * bgint7, so we currently hold the scheduler context */
static CsrBool alsa_process_capture(CsrUint8 index,
                                   av2filter_t **chain,
                                   CsrBool freeData,
                                   void *data,
                                   CsrUint32 length)
{
    alsa_instance_t *inst;
    CsrUint32 copy;
    CsrBool result;
    inst = (alsa_instance_t*)(chain[index]->f_instance);

    result = TRUE;
    while(result)
    {
        /* Is there an item ready? */
        pthread_mutex_lock(&inst->mutex);
        if(inst->count > 0)
        {
            inst->count--;
            pthread_mutex_unlock(&inst->mutex);
        }
        else
        {
            pthread_mutex_unlock(&inst->mutex);
            result = FALSE;
        }

        /* This is the candidate data */
        if(result)
        {
            /* Copy as much as possible */
            copy = CSRMAX(CAPTURE_THRESHOLD - inst->capsize,
                       inst->lengths[inst->buf_out]);
            CsrMemCpy(inst->capbuf + inst->capsize,
                   inst->buffers[inst->buf_out],
                   copy);
            inst->capsize += copy;

            /* If we got enough data, send it */
            if(inst->capsize >= CAPTURE_THRESHOLD)
            {
                CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "delivering %i bytes\n", inst->capsize);
                result &= chain[index+1]->f_process(index+1,
                                                    chain,
                                                    FALSE,
                                                    inst->capbuf,
                                                    inst->capsize);
                inst->capsize = 0;
            }

            /* Anything left in the ring buffer? */
            if(copy < inst->lengths[inst->buf_out])
            {
                CsrMemCpy(inst->capbuf,
                       inst->buffers[inst->buf_out] + copy,
                       inst->lengths[inst->buf_out] - copy);
                inst->capsize = inst->lengths[inst->buf_out] - copy;
            }

            /* Get ready for next buffer */
            inst->buf_out = (inst->buf_out + 1) % BUFFERS;

#ifdef VERBOSE_DEBUG
            CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "process done send\n");
#endif
        }
    }

    /* Done */
    {
        static int foo = 0;
        foo++;
        if(foo > 10)
        {
            CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,ALSA_PRN "capture count %i\n", inst->count);
            foo = 0;
        }
    }
    return result;
}

/* Return alsa configuration */
static CsrUint8 *alsa_get_config(void **instance,
                                CsrUint8 *conf_len)
{
    /* We do not support this feature */
    *conf_len = 0;
    return NULL;
}

/* Set alsa configuration */
static CsrBtAvResult alsa_set_config(void **instance,
                                   CsrUint8 *conf,
                                   CsrUint8 conf_len)
{
    /* We do not support this feature */
    return CSR_BT_AV_ACCEPT;
}

/* Return alsa service capabilities */
static CsrUint8 *alsa_get_caps(void **instance,
                              CsrUint8 *cap_len)
{
    /* We do not support this feature */
    *cap_len = 0;
    return NULL;
}

/* Investigate remote capabilities, return optimal configuration */
static CsrUint8 *alsa_remote_caps(void **instance,
                                 CsrUint8 *caps,
                                 CsrUint8 caps_len,
                                 CsrUint8 *conf_len)
{
    /* We do not support this feature */
    *conf_len = 0;
    return NULL;
}

static void alsa_qos_update(void **instance,
                            CsrUint16 qosLevel)
{
    /* Not supported */
}

/* Print menu options to screen */
static void alsa_menu(void **instance,
                      CsrUint8 *num_options)
{
    /* Not supported */
    CsrAppBacklogReqSend(TECH_BT, PROFILE_AV, FALSE,"  ALSA playback/capture does not support menu options\n");
    *num_options = 0;
}

/* Set user option */
static CsrBool alsa_setup(void **instance,
                         CsrUint8 index,
                         char *value)
{
    /* Not supported */
    CsrPmemFree(value);
    return FALSE;
}
